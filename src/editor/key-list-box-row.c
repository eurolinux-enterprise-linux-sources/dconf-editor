/* key-list-box-row.c generated by valac 0.35.3.1-efc5, the Vala compiler
 * generated from key-list-box-row.vala, do not modify */

/*
  This file is part of Dconf Editor

  Dconf Editor is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  Dconf Editor is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with Dconf Editor.  If not, see <http://www.gnu.org/licenses/>.
*/

#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <stdlib.h>
#include <string.h>
#include <cairo.h>
#include <gdk/gdk.h>
#include <glib/gi18n-lib.h>
#include <gio/gio.h>


#define TYPE_CLICKABLE_LIST_BOX_ROW (clickable_list_box_row_get_type ())
#define CLICKABLE_LIST_BOX_ROW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CLICKABLE_LIST_BOX_ROW, ClickableListBoxRow))
#define CLICKABLE_LIST_BOX_ROW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CLICKABLE_LIST_BOX_ROW, ClickableListBoxRowClass))
#define IS_CLICKABLE_LIST_BOX_ROW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CLICKABLE_LIST_BOX_ROW))
#define IS_CLICKABLE_LIST_BOX_ROW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CLICKABLE_LIST_BOX_ROW))
#define CLICKABLE_LIST_BOX_ROW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CLICKABLE_LIST_BOX_ROW, ClickableListBoxRowClass))

typedef struct _ClickableListBoxRow ClickableListBoxRow;
typedef struct _ClickableListBoxRowClass ClickableListBoxRowClass;
typedef struct _ClickableListBoxRowPrivate ClickableListBoxRowPrivate;

#define TYPE_CONTEXT_POPOVER (context_popover_get_type ())
#define CONTEXT_POPOVER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CONTEXT_POPOVER, ContextPopover))
#define CONTEXT_POPOVER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CONTEXT_POPOVER, ContextPopoverClass))
#define IS_CONTEXT_POPOVER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CONTEXT_POPOVER))
#define IS_CONTEXT_POPOVER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CONTEXT_POPOVER))
#define CONTEXT_POPOVER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CONTEXT_POPOVER, ContextPopoverClass))

typedef struct _ContextPopover ContextPopover;
typedef struct _ContextPopoverClass ContextPopoverClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
enum  {
	CLICKABLE_LIST_BOX_ROW_ON_ROW_CLICKED_SIGNAL,
	CLICKABLE_LIST_BOX_ROW_LAST_SIGNAL
};
static guint clickable_list_box_row_signals[CLICKABLE_LIST_BOX_ROW_LAST_SIGNAL] = {0};

#define TYPE_FOLDER_LIST_BOX_ROW (folder_list_box_row_get_type ())
#define FOLDER_LIST_BOX_ROW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FOLDER_LIST_BOX_ROW, FolderListBoxRow))
#define FOLDER_LIST_BOX_ROW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_FOLDER_LIST_BOX_ROW, FolderListBoxRowClass))
#define IS_FOLDER_LIST_BOX_ROW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FOLDER_LIST_BOX_ROW))
#define IS_FOLDER_LIST_BOX_ROW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_FOLDER_LIST_BOX_ROW))
#define FOLDER_LIST_BOX_ROW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_FOLDER_LIST_BOX_ROW, FolderListBoxRowClass))

typedef struct _FolderListBoxRow FolderListBoxRow;
typedef struct _FolderListBoxRowClass FolderListBoxRowClass;
typedef struct _FolderListBoxRowPrivate FolderListBoxRowPrivate;

#define TYPE_KEY_LIST_BOX_ROW (key_list_box_row_get_type ())
#define KEY_LIST_BOX_ROW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_KEY_LIST_BOX_ROW, KeyListBoxRow))
#define KEY_LIST_BOX_ROW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_KEY_LIST_BOX_ROW, KeyListBoxRowClass))
#define IS_KEY_LIST_BOX_ROW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_KEY_LIST_BOX_ROW))
#define IS_KEY_LIST_BOX_ROW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_KEY_LIST_BOX_ROW))
#define KEY_LIST_BOX_ROW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_KEY_LIST_BOX_ROW, KeyListBoxRowClass))

typedef struct _KeyListBoxRow KeyListBoxRow;
typedef struct _KeyListBoxRowClass KeyListBoxRowClass;
typedef struct _KeyListBoxRowPrivate KeyListBoxRowPrivate;

#define TYPE_SETTING_OBJECT (setting_object_get_type ())
#define SETTING_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SETTING_OBJECT, SettingObject))
#define SETTING_OBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SETTING_OBJECT, SettingObjectClass))
#define IS_SETTING_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SETTING_OBJECT))
#define IS_SETTING_OBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SETTING_OBJECT))
#define SETTING_OBJECT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SETTING_OBJECT, SettingObjectClass))

typedef struct _SettingObject SettingObject;
typedef struct _SettingObjectClass SettingObjectClass;

#define TYPE_KEY (key_get_type ())
#define KEY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_KEY, Key))
#define KEY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_KEY, KeyClass))
#define IS_KEY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_KEY))
#define IS_KEY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_KEY))
#define KEY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_KEY, KeyClass))

typedef struct _Key Key;
typedef struct _KeyClass KeyClass;
#define _g_variant_unref0(var) ((var == NULL) ? NULL : (var = (g_variant_unref (var), NULL)))
typedef struct _Block11Data Block11Data;
enum  {
	KEY_LIST_BOX_ROW_SET_KEY_VALUE_SIGNAL,
	KEY_LIST_BOX_ROW_CHANGE_DISMISSED_SIGNAL,
	KEY_LIST_BOX_ROW_LAST_SIGNAL
};
static guint key_list_box_row_signals[KEY_LIST_BOX_ROW_LAST_SIGNAL] = {0};

#define TYPE_KEY_LIST_BOX_ROW_EDITABLE_NO_SCHEMA (key_list_box_row_editable_no_schema_get_type ())
#define KEY_LIST_BOX_ROW_EDITABLE_NO_SCHEMA(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_KEY_LIST_BOX_ROW_EDITABLE_NO_SCHEMA, KeyListBoxRowEditableNoSchema))
#define KEY_LIST_BOX_ROW_EDITABLE_NO_SCHEMA_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_KEY_LIST_BOX_ROW_EDITABLE_NO_SCHEMA, KeyListBoxRowEditableNoSchemaClass))
#define IS_KEY_LIST_BOX_ROW_EDITABLE_NO_SCHEMA(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_KEY_LIST_BOX_ROW_EDITABLE_NO_SCHEMA))
#define IS_KEY_LIST_BOX_ROW_EDITABLE_NO_SCHEMA_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_KEY_LIST_BOX_ROW_EDITABLE_NO_SCHEMA))
#define KEY_LIST_BOX_ROW_EDITABLE_NO_SCHEMA_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_KEY_LIST_BOX_ROW_EDITABLE_NO_SCHEMA, KeyListBoxRowEditableNoSchemaClass))

typedef struct _KeyListBoxRowEditableNoSchema KeyListBoxRowEditableNoSchema;
typedef struct _KeyListBoxRowEditableNoSchemaClass KeyListBoxRowEditableNoSchemaClass;
typedef struct _KeyListBoxRowEditableNoSchemaPrivate KeyListBoxRowEditableNoSchemaPrivate;

#define TYPE_DCONF_KEY (dconf_key_get_type ())
#define DCONF_KEY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_DCONF_KEY, DConfKey))
#define DCONF_KEY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_DCONF_KEY, DConfKeyClass))
#define IS_DCONF_KEY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_DCONF_KEY))
#define IS_DCONF_KEY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_DCONF_KEY))
#define DCONF_KEY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_DCONF_KEY, DConfKeyClass))

typedef struct _DConfKey DConfKey;
typedef struct _DConfKeyClass DConfKeyClass;
typedef struct _Block12Data Block12Data;
#define _g_variant_type_free0(var) ((var == NULL) ? NULL : (var = (g_variant_type_free (var), NULL)))

#define TYPE_KEY_LIST_BOX_ROW_EDITABLE (key_list_box_row_editable_get_type ())
#define KEY_LIST_BOX_ROW_EDITABLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_KEY_LIST_BOX_ROW_EDITABLE, KeyListBoxRowEditable))
#define KEY_LIST_BOX_ROW_EDITABLE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_KEY_LIST_BOX_ROW_EDITABLE, KeyListBoxRowEditableClass))
#define IS_KEY_LIST_BOX_ROW_EDITABLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_KEY_LIST_BOX_ROW_EDITABLE))
#define IS_KEY_LIST_BOX_ROW_EDITABLE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_KEY_LIST_BOX_ROW_EDITABLE))
#define KEY_LIST_BOX_ROW_EDITABLE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_KEY_LIST_BOX_ROW_EDITABLE, KeyListBoxRowEditableClass))

typedef struct _KeyListBoxRowEditable KeyListBoxRowEditable;
typedef struct _KeyListBoxRowEditableClass KeyListBoxRowEditableClass;
typedef struct _KeyListBoxRowEditablePrivate KeyListBoxRowEditablePrivate;

#define TYPE_GSETTINGS_KEY (gsettings_key_get_type ())
#define GSETTINGS_KEY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GSETTINGS_KEY, GSettingsKey))
#define GSETTINGS_KEY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_GSETTINGS_KEY, GSettingsKeyClass))
#define IS_GSETTINGS_KEY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GSETTINGS_KEY))
#define IS_GSETTINGS_KEY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_GSETTINGS_KEY))
#define GSETTINGS_KEY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_GSETTINGS_KEY, GSettingsKeyClass))

typedef struct _GSettingsKey GSettingsKey;
typedef struct _GSettingsKeyClass GSettingsKeyClass;
typedef struct _Block13Data Block13Data;
typedef struct _ContextPopoverPrivate ContextPopoverPrivate;
typedef struct _Block14Data Block14Data;
typedef struct _Block15Data Block15Data;
typedef struct _Block16Data Block16Data;
enum  {
	CONTEXT_POPOVER_VALUE_CHANGED_SIGNAL,
	CONTEXT_POPOVER_CHANGE_DISMISSED_SIGNAL,
	CONTEXT_POPOVER_LAST_SIGNAL
};
static guint context_popover_signals[CONTEXT_POPOVER_LAST_SIGNAL] = {0};
#define _vala_assert(expr, msg) if G_LIKELY (expr) ; else g_assertion_message_expr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);
#define _vala_return_if_fail(expr, msg) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return; }
#define _vala_return_val_if_fail(expr, msg, val) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return val; }
#define _vala_warn_if_fail(expr, msg) if G_LIKELY (expr) ; else g_warn_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);

struct _ClickableListBoxRow {
	GtkEventBox parent_instance;
	ClickableListBoxRowPrivate * priv;
};

struct _ClickableListBoxRowClass {
	GtkEventBoxClass parent_class;
	gchar* (*get_text) (ClickableListBoxRow* self);
	gboolean (*generate_popover) (ClickableListBoxRow* self, ContextPopover* popover, gboolean delayed_apply_menu);
};

struct _ClickableListBoxRowPrivate {
	gint width;
	ContextPopover* nullable_popover;
};

struct _FolderListBoxRow {
	ClickableListBoxRow parent_instance;
	FolderListBoxRowPrivate * priv;
};

struct _FolderListBoxRowClass {
	ClickableListBoxRowClass parent_class;
};

struct _FolderListBoxRowPrivate {
	GtkLabel* folder_name_label;
	gchar* full_name;
};

typedef void (*ContextPopoverbutton_action) (void* user_data);
struct _KeyListBoxRow {
	ClickableListBoxRow parent_instance;
	KeyListBoxRowPrivate * priv;
	GtkLabel* key_value_label;
	GtkLabel* key_info_label;
	GtkStyleContext* name_context;
	GtkStyleContext* value_context;
};

struct _KeyListBoxRowClass {
	ClickableListBoxRowClass parent_class;
	void (*update) (KeyListBoxRow* self);
	Key* (*get_abstract_key) (KeyListBoxRow* self);
};

struct _KeyListBoxRowPrivate {
	GtkLabel* key_name_label;
};

struct _Block11Data {
	int _ref_count_;
	KeyListBoxRow* self;
	gulong key_value_changed_handler;
};

struct _KeyListBoxRowEditableNoSchema {
	KeyListBoxRow parent_instance;
	KeyListBoxRowEditableNoSchemaPrivate * priv;
};

struct _KeyListBoxRowEditableNoSchemaClass {
	KeyListBoxRowClass parent_class;
};

struct _KeyListBoxRowEditableNoSchemaPrivate {
	DConfKey* _key;
};

struct _Block12Data {
	int _ref_count_;
	KeyListBoxRowEditableNoSchema* self;
	GAction* action;
};

struct _KeyListBoxRowEditable {
	KeyListBoxRow parent_instance;
	KeyListBoxRowEditablePrivate * priv;
};

struct _KeyListBoxRowEditableClass {
	KeyListBoxRowClass parent_class;
};

struct _KeyListBoxRowEditablePrivate {
	GSettingsKey* _key;
};

struct _Block13Data {
	int _ref_count_;
	KeyListBoxRowEditable* self;
	gchar* real_type_string;
	GAction* action;
};

struct _ContextPopover {
	GtkPopover parent_instance;
	ContextPopoverPrivate * priv;
};

struct _ContextPopoverClass {
	GtkPopoverClass parent_class;
};

struct _ContextPopoverPrivate {
	GMenu* menu;
	GMenu* current_section;
	GActionMap* current_group;
};

struct _Block14Data {
	int _ref_count_;
	ContextPopover* self;
	ContextPopoverbutton_action action;
	gpointer action_target;
};

struct _Block15Data {
	int _ref_count_;
	ContextPopover* self;
	gchar** active_flags;
	gint active_flags_length1;
	gint _active_flags_size_;
	GSimpleAction** flags_actions;
	gint flags_actions_length1;
	gint _flags_actions_size_;
	GSettingsKey* key;
};

struct _Block16Data {
	int _ref_count_;
	Block15Data * _data15_;
	gchar* flag;
	GSimpleAction* simple_action;
};


static gpointer clickable_list_box_row_parent_class = NULL;
static gpointer folder_list_box_row_parent_class = NULL;
static gpointer key_list_box_row_parent_class = NULL;
static gpointer key_list_box_row_editable_no_schema_parent_class = NULL;
static gpointer key_list_box_row_editable_parent_class = NULL;
static gpointer context_popover_parent_class = NULL;

GType clickable_list_box_row_get_type (void) G_GNUC_CONST;
GType context_popover_get_type (void) G_GNUC_CONST;
#define CLICKABLE_LIST_BOX_ROW_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_CLICKABLE_LIST_BOX_ROW, ClickableListBoxRowPrivate))
enum  {
	CLICKABLE_LIST_BOX_ROW_DUMMY_PROPERTY
};
gchar* clickable_list_box_row_get_text (ClickableListBoxRow* self);
static gchar* clickable_list_box_row_real_get_text (ClickableListBoxRow* self);
static void clickable_list_box_row_on_size_allocate (ClickableListBoxRow* self, GtkAllocation* allocation);
void clickable_list_box_row_hide_right_click_popover (ClickableListBoxRow* self);
gboolean clickable_list_box_row_generate_popover (ClickableListBoxRow* self, ContextPopover* popover, gboolean delayed_apply_menu);
static gboolean clickable_list_box_row_real_generate_popover (ClickableListBoxRow* self, ContextPopover* popover, gboolean delayed_apply_menu);
void clickable_list_box_row_destroy_popover (ClickableListBoxRow* self);
void clickable_list_box_row_show_right_click_popover (ClickableListBoxRow* self, gboolean delayed_apply_menu, gint event_x);
ContextPopover* context_popover_new (void);
ContextPopover* context_popover_construct (GType object_type);
static void ___lambda56_ (ClickableListBoxRow* self);
static void ____lambda56__gtk_widget_destroy (GtkWidget* _sender, gpointer self);
ClickableListBoxRow* clickable_list_box_row_construct (GType object_type);
static GObject * clickable_list_box_row_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
static void _clickable_list_box_row_on_size_allocate_gtk_widget_size_allocate (GtkWidget* _sender, GtkAllocation* allocation, gpointer self);
static void clickable_list_box_row_finalize (GObject * obj);
GType folder_list_box_row_get_type (void) G_GNUC_CONST;
#define FOLDER_LIST_BOX_ROW_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_FOLDER_LIST_BOX_ROW, FolderListBoxRowPrivate))
enum  {
	FOLDER_LIST_BOX_ROW_DUMMY_PROPERTY
};
FolderListBoxRow* folder_list_box_row_new (const gchar* label, const gchar* path);
FolderListBoxRow* folder_list_box_row_construct (GType object_type, const gchar* label, const gchar* path);
static gchar* folder_list_box_row_real_get_text (ClickableListBoxRow* base);
static gboolean folder_list_box_row_real_generate_popover (ClickableListBoxRow* base, ContextPopover* popover, gboolean unused);
void context_popover_new_action (ContextPopover* self, const gchar* action_action, ContextPopoverbutton_action action, void* action_target);
static void __lambda57_ (FolderListBoxRow* self);
static void ___lambda57__contextpopoverbutton_action (gpointer self);
void context_popover_new_copy_action (ContextPopover* self, const gchar* text);
static void folder_list_box_row_finalize (GObject * obj);
GType key_list_box_row_get_type (void) G_GNUC_CONST;
GType setting_object_get_type (void) G_GNUC_CONST;
GType key_get_type (void) G_GNUC_CONST;
#define KEY_LIST_BOX_ROW_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_KEY_LIST_BOX_ROW, KeyListBoxRowPrivate))
enum  {
	KEY_LIST_BOX_ROW_DUMMY_PROPERTY
};
gchar* key_list_box_row_cool_text_value (Key* key);
gchar* key_cool_text_value_from_variant (GVariant* variant, const gchar* type);
GVariant* key_get_value (Key* self);
const gchar* key_get_type_string (Key* self);
void key_list_box_row_update (KeyListBoxRow* self);
static void key_list_box_row_real_update (KeyListBoxRow* self);
KeyListBoxRow* key_list_box_row_construct (GType object_type);
static Key* key_list_box_row_get_abstract_key (KeyListBoxRow* self);
static void g_cclosure_user_marshal_VOID__VARIANT (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
static GObject * key_list_box_row_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
static Block11Data* block11_data_ref (Block11Data* _data11_);
static void block11_data_unref (void * _userdata_);
const gchar* setting_object_get_name (SettingObject* self);
static void _key_list_box_row___lambda58_ (KeyListBoxRow* self);
static void __key_list_box_row___lambda58__key_value_changed (Key* _sender, gpointer self);
static void _key_list_box_row___lambda59_ (Block11Data* _data11_);
static void __key_list_box_row___lambda59__gtk_widget_destroy (GtkWidget* _sender, gpointer self);
static void key_list_box_row_finalize (GObject * obj);
static void _vala_key_list_box_row_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
GType key_list_box_row_editable_no_schema_get_type (void) G_GNUC_CONST;
GType dconf_key_get_type (void) G_GNUC_CONST;
#define KEY_LIST_BOX_ROW_EDITABLE_NO_SCHEMA_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_KEY_LIST_BOX_ROW_EDITABLE_NO_SCHEMA, KeyListBoxRowEditableNoSchemaPrivate))
enum  {
	KEY_LIST_BOX_ROW_EDITABLE_NO_SCHEMA_DUMMY_PROPERTY,
	KEY_LIST_BOX_ROW_EDITABLE_NO_SCHEMA_KEY
};
KeyListBoxRowEditableNoSchema* key_list_box_row_editable_no_schema_new (DConfKey* _key);
KeyListBoxRowEditableNoSchema* key_list_box_row_editable_no_schema_construct (GType object_type, DConfKey* _key);
static void key_list_box_row_editable_no_schema_real_update (KeyListBoxRow* base);
DConfKey* key_list_box_row_editable_no_schema_get_key (KeyListBoxRowEditableNoSchema* self);
gboolean dconf_key_get_is_ghost (DConfKey* self);
static gchar* key_list_box_row_editable_no_schema_real_get_text (ClickableListBoxRow* base);
const gchar* setting_object_get_full_name (SettingObject* self);
gchar* key_get_descriptor (Key* self);
static gboolean key_list_box_row_editable_no_schema_real_generate_popover (ClickableListBoxRow* base, ContextPopover* popover, gboolean delayed_apply_menu);
static void __lambda68_ (KeyListBoxRowEditableNoSchema* self);
static void ___lambda68__contextpopoverbutton_action (gpointer self);
static Block12Data* block12_data_ref (Block12Data* _data12_);
static void block12_data_unref (void * _userdata_);
void context_popover_new_section (ContextPopover* self);
GAction* context_popover_create_buttons_list (ContextPopover* self, Key* key, gboolean has_default_value, gboolean delayed_apply_menu);
static void ___lambda69_ (KeyListBoxRowEditableNoSchema* self);
static void ____lambda69__context_popover_change_dismissed (ContextPopover* _sender, gpointer self);
static void ___lambda70_ (Block12Data* _data12_, GVariant* gvariant);
static void ____lambda70__context_popover_value_changed (ContextPopover* _sender, GVariant* gvariant, gpointer self);
static void ____lambda71_ (KeyListBoxRowEditableNoSchema* self);
static void _____lambda71__contextpopoverbutton_action (gpointer self);
gboolean key_get_planned_change (Key* self);
GVariant* key_get_planned_value (Key* self);
static void ____lambda72_ (KeyListBoxRowEditableNoSchema* self);
static void _____lambda72__contextpopoverbutton_action (gpointer self);
static void ____lambda73_ (KeyListBoxRowEditableNoSchema* self);
static void _____lambda73__contextpopoverbutton_action (gpointer self);
static void key_list_box_row_editable_no_schema_set_key (KeyListBoxRowEditableNoSchema* self, DConfKey* value);
static void key_list_box_row_editable_no_schema_finalize (GObject * obj);
static void _vala_key_list_box_row_editable_no_schema_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_key_list_box_row_editable_no_schema_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
GType key_list_box_row_editable_get_type (void) G_GNUC_CONST;
GType gsettings_key_get_type (void) G_GNUC_CONST;
#define KEY_LIST_BOX_ROW_EDITABLE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_KEY_LIST_BOX_ROW_EDITABLE, KeyListBoxRowEditablePrivate))
enum  {
	KEY_LIST_BOX_ROW_EDITABLE_DUMMY_PROPERTY,
	KEY_LIST_BOX_ROW_EDITABLE_KEY
};
KeyListBoxRowEditable* key_list_box_row_editable_new (GSettingsKey* _key);
KeyListBoxRowEditable* key_list_box_row_editable_construct (GType object_type, GSettingsKey* _key);
GSettingsKey* key_list_box_row_editable_get_key (KeyListBoxRowEditable* self);
const gchar* gsettings_key_get_summary (GSettingsKey* self);
static void key_list_box_row_editable_real_update (KeyListBoxRow* base);
gboolean gsettings_key_get_is_default (GSettingsKey* self);
static gchar* key_list_box_row_editable_real_get_text (ClickableListBoxRow* base);
static gboolean key_list_box_row_editable_real_generate_popover (ClickableListBoxRow* base, ContextPopover* popover, gboolean delayed_apply_menu);
static void __lambda60_ (KeyListBoxRowEditable* self);
static void ___lambda60__contextpopoverbutton_action (gpointer self);
static Block13Data* block13_data_ref (Block13Data* _data13_);
static void block13_data_unref (void * _userdata_);
static void ___lambda61_ (KeyListBoxRowEditable* self);
static void ____lambda61__context_popover_change_dismissed (ContextPopover* _sender, gpointer self);
static void ___lambda62_ (Block13Data* _data13_, GVariant* gvariant);
static void ____lambda62__context_popover_value_changed (ContextPopover* _sender, GVariant* gvariant, gpointer self);
static void _____lambda63_ (KeyListBoxRowEditable* self);
static void ______lambda63__contextpopoverbutton_action (gpointer self);
void context_popover_set_group (ContextPopover* self, const gchar* group_name);
void context_popover_create_flags_list (ContextPopover* self, GSettingsKey* key);
static void ____lambda64_ (KeyListBoxRowEditable* self, GVariant* gvariant);
static void _____lambda64__context_popover_value_changed (ContextPopover* _sender, GVariant* gvariant, gpointer self);
static void _____lambda65_ (KeyListBoxRowEditable* self);
static void ______lambda65__contextpopoverbutton_action (gpointer self);
static void ______lambda66_ (KeyListBoxRowEditable* self);
static void _______lambda66__contextpopoverbutton_action (gpointer self);
static void ______lambda67_ (KeyListBoxRowEditable* self);
static void _______lambda67__contextpopoverbutton_action (gpointer self);
static void key_list_box_row_editable_set_key (KeyListBoxRowEditable* self, GSettingsKey* value);
static void key_list_box_row_editable_finalize (GObject * obj);
static void _vala_key_list_box_row_editable_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_key_list_box_row_editable_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
#define CONTEXT_POPOVER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_CONTEXT_POPOVER, ContextPopoverPrivate))
enum  {
	CONTEXT_POPOVER_DUMMY_PROPERTY
};
static void context_popover_new_section_real (ContextPopover* self);
static gboolean context_popover_on_key_press_event (ContextPopover* self, GtkWidget* widget, GdkEventKey* event);
static gboolean _context_popover_on_key_press_event_gtk_widget_key_press_event (GtkWidget* _sender, GdkEventKey* event, gpointer self);
static Block14Data* block14_data_ref (Block14Data* _data14_);
static void block14_data_unref (void * _userdata_);
static void __lambda26_ (Block14Data* _data14_);
static void ___lambda26__g_simple_action_activate (GSimpleAction* _sender, GVariant* parameter, gpointer self);
static void context_popover_new_multi_default_action (ContextPopover* self, const gchar* action);
static Block15Data* block15_data_ref (Block15Data* _data15_);
static void block15_data_unref (void * _userdata_);
const gchar* gsettings_key_get_schema_id (GSettingsKey* self);
GVariant* gsettings_key_get_range_content (GSettingsKey* self);
static gchar** _vala_array_dup1 (gchar** self, int length);
static Block16Data* block16_data_ref (Block16Data* _data16_);
static void block16_data_unref (void * _userdata_);
static gboolean _vala_string_array_contains (gchar* * stack, int stack_length, gchar* needle);
static void _vala_array_add3 (GSimpleAction** * array, int* length, int* size, GSimpleAction* value);
static void ____lambda27_ (Block16Data* _data16_, GSimpleAction* gaction, GVariant* gvariant);
static void _vala_array_add4 (gchar** * array, int* length, int* size, gchar* value);
static void _____lambda27__g_simple_action_change_state (GSimpleAction* _sender, GVariant* value, gpointer self);
static void ____lambda28_ (Block16Data* _data16_);
static gchar** _vala_array_dup2 (gchar** self, int length);
static void _____lambda28__g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self);
static void context_popover_finalize_menu (ContextPopover* self);
gchar* key_cool_boolean_text_value (gboolean* nullable_boolean, gboolean capitalized);
static void __lambda29_ (ContextPopover* self, const gchar* unknown_string, GVariant* tmp_variant);
static void ___lambda29__g_action_group_action_state_changed (GActionGroup* _sender, const gchar* action_name, GVariant* state, gpointer self);
static void context_popover_finalize (GObject * obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);


static gchar* clickable_list_box_row_real_get_text (ClickableListBoxRow* self) {
	g_critical ("Type `%s' does not implement abstract method `clickable_list_box_row_get_text'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return NULL;
}


gchar* clickable_list_box_row_get_text (ClickableListBoxRow* self) {
	g_return_val_if_fail (self != NULL, NULL);
	return CLICKABLE_LIST_BOX_ROW_GET_CLASS (self)->get_text (self);
}


static void clickable_list_box_row_on_size_allocate (ClickableListBoxRow* self, GtkAllocation* allocation) {
	GtkAllocation _tmp0_;
	gint _tmp1_;
	gint _tmp2_;
	GtkAllocation _tmp3_;
	gint _tmp4_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (allocation != NULL);
	_tmp0_ = *allocation;
	_tmp1_ = _tmp0_.width;
	_tmp2_ = self->priv->width;
	if (_tmp1_ == _tmp2_) {
		return;
	}
	clickable_list_box_row_hide_right_click_popover (self);
	_tmp3_ = *allocation;
	_tmp4_ = _tmp3_.width;
	self->priv->width = _tmp4_;
}


static gboolean clickable_list_box_row_real_generate_popover (ClickableListBoxRow* self, ContextPopover* popover, gboolean delayed_apply_menu) {
	gboolean result = FALSE;
	g_return_val_if_fail (popover != NULL, FALSE);
	result = FALSE;
	return result;
}


gboolean clickable_list_box_row_generate_popover (ClickableListBoxRow* self, ContextPopover* popover, gboolean delayed_apply_menu) {
	g_return_val_if_fail (self != NULL, FALSE);
	return CLICKABLE_LIST_BOX_ROW_GET_CLASS (self)->generate_popover (self, popover, delayed_apply_menu);
}


void clickable_list_box_row_destroy_popover (ClickableListBoxRow* self) {
	ContextPopover* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->nullable_popover;
	if (_tmp0_ != NULL) {
		ContextPopover* _tmp1_;
		_tmp1_ = self->priv->nullable_popover;
		gtk_widget_destroy ((GtkWidget*) G_TYPE_CHECK_INSTANCE_CAST (_tmp1_, TYPE_CONTEXT_POPOVER, ContextPopover));
	}
}


void clickable_list_box_row_hide_right_click_popover (ClickableListBoxRow* self) {
	ContextPopover* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->nullable_popover;
	if (_tmp0_ != NULL) {
		ContextPopover* _tmp1_;
		_tmp1_ = self->priv->nullable_popover;
		gtk_popover_popdown ((GtkPopover*) G_TYPE_CHECK_INSTANCE_CAST (_tmp1_, TYPE_CONTEXT_POPOVER, ContextPopover));
	}
}


static void ___lambda56_ (ClickableListBoxRow* self) {
	_g_object_unref0 (self->priv->nullable_popover);
	self->priv->nullable_popover = NULL;
}


static void ____lambda56__gtk_widget_destroy (GtkWidget* _sender, gpointer self) {
	___lambda56_ ((ClickableListBoxRow*) self);
}


void clickable_list_box_row_show_right_click_popover (ClickableListBoxRow* self, gboolean delayed_apply_menu, gint event_x) {
	ContextPopover* _tmp0_;
	GdkRectangle rect;
	gint _tmp12_;
	gint _tmp13_;
	GdkRectangle _tmp14_ = {0};
	ContextPopover* _tmp15_;
	GdkRectangle _tmp16_;
	ContextPopover* _tmp17_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->nullable_popover;
	if (_tmp0_ == NULL) {
		ContextPopover* _tmp1_;
		ContextPopover* _tmp2_;
		gboolean _tmp3_;
		gboolean _tmp4_;
		ContextPopover* _tmp6_;
		ContextPopover* _tmp7_;
		ContextPopover* _tmp8_;
		_tmp1_ = context_popover_new ();
		g_object_ref_sink (_tmp1_);
		_g_object_unref0 (self->priv->nullable_popover);
		self->priv->nullable_popover = _tmp1_;
		_tmp2_ = self->priv->nullable_popover;
		_tmp3_ = delayed_apply_menu;
		_tmp4_ = clickable_list_box_row_generate_popover (self, G_TYPE_CHECK_INSTANCE_CAST (_tmp2_, TYPE_CONTEXT_POPOVER, ContextPopover), _tmp3_);
		if (!_tmp4_) {
			ContextPopover* _tmp5_;
			_tmp5_ = self->priv->nullable_popover;
			gtk_widget_destroy ((GtkWidget*) G_TYPE_CHECK_INSTANCE_CAST (_tmp5_, TYPE_CONTEXT_POPOVER, ContextPopover));
			_g_object_unref0 (self->priv->nullable_popover);
			self->priv->nullable_popover = NULL;
			return;
		}
		_tmp6_ = self->priv->nullable_popover;
		g_signal_connect_object ((GtkWidget*) G_TYPE_CHECK_INSTANCE_CAST (_tmp6_, TYPE_CONTEXT_POPOVER, ContextPopover), "destroy", (GCallback) ____lambda56__gtk_widget_destroy, self, 0);
		_tmp7_ = self->priv->nullable_popover;
		gtk_popover_set_relative_to ((GtkPopover*) G_TYPE_CHECK_INSTANCE_CAST (_tmp7_, TYPE_CONTEXT_POPOVER, ContextPopover), (GtkWidget*) self);
		_tmp8_ = self->priv->nullable_popover;
		gtk_popover_set_position ((GtkPopover*) G_TYPE_CHECK_INSTANCE_CAST (_tmp8_, TYPE_CONTEXT_POPOVER, ContextPopover), GTK_POS_BOTTOM);
	} else {
		ContextPopover* _tmp9_;
		gboolean _tmp10_;
		gboolean _tmp11_;
		_tmp9_ = self->priv->nullable_popover;
		_tmp10_ = gtk_widget_get_visible ((GtkWidget*) G_TYPE_CHECK_INSTANCE_CAST (_tmp9_, TYPE_CONTEXT_POPOVER, ContextPopover));
		_tmp11_ = _tmp10_;
		if (_tmp11_) {
			g_warning ("key-list-box-row.vala:82: show_right_click_popover() called but popove" \
"r is visible");
		}
	}
	_tmp12_ = event_x;
	_tmp13_ = gtk_widget_get_allocated_height ((GtkWidget*) self);
	_tmp14_.x = _tmp12_;
	_tmp14_.y = _tmp13_;
	_tmp14_.width = 0;
	_tmp14_.height = 0;
	rect = _tmp14_;
	_tmp15_ = self->priv->nullable_popover;
	_tmp16_ = rect;
	gtk_popover_set_pointing_to ((GtkPopover*) G_TYPE_CHECK_INSTANCE_CAST (_tmp15_, TYPE_CONTEXT_POPOVER, ContextPopover), &_tmp16_);
	_tmp17_ = self->priv->nullable_popover;
	gtk_popover_popup ((GtkPopover*) G_TYPE_CHECK_INSTANCE_CAST (_tmp17_, TYPE_CONTEXT_POPOVER, ContextPopover));
}


ClickableListBoxRow* clickable_list_box_row_construct (GType object_type) {
	ClickableListBoxRow * self = NULL;
	self = (ClickableListBoxRow*) g_object_new (object_type, NULL);
	return self;
}


static void _clickable_list_box_row_on_size_allocate_gtk_widget_size_allocate (GtkWidget* _sender, GtkAllocation* allocation, gpointer self) {
	clickable_list_box_row_on_size_allocate ((ClickableListBoxRow*) self, allocation);
}


static GObject * clickable_list_box_row_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	ClickableListBoxRow * self;
	parent_class = G_OBJECT_CLASS (clickable_list_box_row_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_CLICKABLE_LIST_BOX_ROW, ClickableListBoxRow);
	g_signal_connect_object ((GtkWidget*) self, "size-allocate", (GCallback) _clickable_list_box_row_on_size_allocate_gtk_widget_size_allocate, self, 0);
	return obj;
}


static void clickable_list_box_row_class_init (ClickableListBoxRowClass * klass) {
	clickable_list_box_row_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (ClickableListBoxRowPrivate));
	((ClickableListBoxRowClass *) klass)->get_text = clickable_list_box_row_real_get_text;
	((ClickableListBoxRowClass *) klass)->generate_popover = clickable_list_box_row_real_generate_popover;
	G_OBJECT_CLASS (klass)->constructor = clickable_list_box_row_constructor;
	G_OBJECT_CLASS (klass)->finalize = clickable_list_box_row_finalize;
	clickable_list_box_row_signals[CLICKABLE_LIST_BOX_ROW_ON_ROW_CLICKED_SIGNAL] = g_signal_new ("on_row_clicked", TYPE_CLICKABLE_LIST_BOX_ROW, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
}


static void clickable_list_box_row_instance_init (ClickableListBoxRow * self) {
	self->priv = CLICKABLE_LIST_BOX_ROW_GET_PRIVATE (self);
	self->priv->nullable_popover = NULL;
}


static void clickable_list_box_row_finalize (GObject * obj) {
	ClickableListBoxRow * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_CLICKABLE_LIST_BOX_ROW, ClickableListBoxRow);
	_g_object_unref0 (self->priv->nullable_popover);
	G_OBJECT_CLASS (clickable_list_box_row_parent_class)->finalize (obj);
}


GType clickable_list_box_row_get_type (void) {
	static volatile gsize clickable_list_box_row_type_id__volatile = 0;
	if (g_once_init_enter (&clickable_list_box_row_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ClickableListBoxRowClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) clickable_list_box_row_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ClickableListBoxRow), 0, (GInstanceInitFunc) clickable_list_box_row_instance_init, NULL };
		GType clickable_list_box_row_type_id;
		clickable_list_box_row_type_id = g_type_register_static (gtk_event_box_get_type (), "ClickableListBoxRow", &g_define_type_info, G_TYPE_FLAG_ABSTRACT);
		g_once_init_leave (&clickable_list_box_row_type_id__volatile, clickable_list_box_row_type_id);
	}
	return clickable_list_box_row_type_id__volatile;
}


FolderListBoxRow* folder_list_box_row_construct (GType object_type, const gchar* label, const gchar* path) {
	FolderListBoxRow * self = NULL;
	GtkLabel* _tmp0_;
	const gchar* _tmp1_;
	const gchar* _tmp2_;
	gchar* _tmp3_;
	g_return_val_if_fail (label != NULL, NULL);
	g_return_val_if_fail (path != NULL, NULL);
	self = (FolderListBoxRow*) clickable_list_box_row_construct (object_type);
	_tmp0_ = self->priv->folder_name_label;
	_tmp1_ = label;
	gtk_label_set_text (_tmp0_, _tmp1_);
	_tmp2_ = path;
	_tmp3_ = g_strdup (_tmp2_);
	g_free (self->priv->full_name);
	self->priv->full_name = _tmp3_;
	return self;
}


FolderListBoxRow* folder_list_box_row_new (const gchar* label, const gchar* path) {
	return folder_list_box_row_construct (TYPE_FOLDER_LIST_BOX_ROW, label, path);
}


static gchar* folder_list_box_row_real_get_text (ClickableListBoxRow* base) {
	FolderListBoxRow * self;
	gchar* result = NULL;
	const gchar* _tmp0_;
	gchar* _tmp1_;
	self = (FolderListBoxRow*) base;
	_tmp0_ = self->priv->full_name;
	_tmp1_ = g_strdup (_tmp0_);
	result = _tmp1_;
	return result;
}


static void __lambda57_ (FolderListBoxRow* self) {
	g_signal_emit ((ClickableListBoxRow*) self, clickable_list_box_row_signals[CLICKABLE_LIST_BOX_ROW_ON_ROW_CLICKED_SIGNAL], 0);
}


static void ___lambda57__contextpopoverbutton_action (gpointer self) {
	__lambda57_ ((FolderListBoxRow*) self);
}


static gboolean folder_list_box_row_real_generate_popover (ClickableListBoxRow* base, ContextPopover* popover, gboolean unused) {
	FolderListBoxRow * self;
	gboolean result = FALSE;
	ContextPopover* _tmp0_;
	ContextPopover* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	self = (FolderListBoxRow*) base;
	g_return_val_if_fail (popover != NULL, FALSE);
	_tmp0_ = popover;
	context_popover_new_action (_tmp0_, "open", ___lambda57__contextpopoverbutton_action, self);
	_tmp1_ = popover;
	_tmp2_ = clickable_list_box_row_get_text ((ClickableListBoxRow*) self);
	_tmp3_ = _tmp2_;
	context_popover_new_copy_action (_tmp1_, _tmp3_);
	g_free (_tmp3_);
	result = TRUE;
	return result;
}


static void folder_list_box_row_class_init (FolderListBoxRowClass * klass) {
	gint FolderListBoxRow_private_offset;
	folder_list_box_row_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (FolderListBoxRowPrivate));
	((ClickableListBoxRowClass *) klass)->get_text = folder_list_box_row_real_get_text;
	((ClickableListBoxRowClass *) klass)->generate_popover = folder_list_box_row_real_generate_popover;
	G_OBJECT_CLASS (klass)->finalize = folder_list_box_row_finalize;
	FolderListBoxRow_private_offset = g_type_class_get_instance_private_offset (klass);
	gtk_widget_class_set_template_from_resource (GTK_WIDGET_CLASS (klass), "/ca/desrt/dconf-editor/ui/folder-list-box-row.ui");
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "folder_name_label", FALSE, FolderListBoxRow_private_offset + G_STRUCT_OFFSET (FolderListBoxRowPrivate, folder_name_label));
}


static void folder_list_box_row_instance_init (FolderListBoxRow * self) {
	self->priv = FOLDER_LIST_BOX_ROW_GET_PRIVATE (self);
	gtk_widget_init_template (GTK_WIDGET (self));
}


static void folder_list_box_row_finalize (GObject * obj) {
	FolderListBoxRow * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_FOLDER_LIST_BOX_ROW, FolderListBoxRow);
	_g_object_unref0 (self->priv->folder_name_label);
	g_free (self->priv->full_name);
	G_OBJECT_CLASS (folder_list_box_row_parent_class)->finalize (obj);
}


GType folder_list_box_row_get_type (void) {
	static volatile gsize folder_list_box_row_type_id__volatile = 0;
	if (g_once_init_enter (&folder_list_box_row_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FolderListBoxRowClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) folder_list_box_row_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FolderListBoxRow), 0, (GInstanceInitFunc) folder_list_box_row_instance_init, NULL };
		GType folder_list_box_row_type_id;
		folder_list_box_row_type_id = g_type_register_static (TYPE_CLICKABLE_LIST_BOX_ROW, "FolderListBoxRow", &g_define_type_info, 0);
		g_once_init_leave (&folder_list_box_row_type_id__volatile, folder_list_box_row_type_id);
	}
	return folder_list_box_row_type_id__volatile;
}


gchar* key_list_box_row_cool_text_value (Key* key) {
	gchar* result = NULL;
	Key* _tmp0_;
	GVariant* _tmp1_;
	GVariant* _tmp2_;
	GVariant* _tmp3_;
	Key* _tmp4_;
	const gchar* _tmp5_;
	const gchar* _tmp6_;
	gchar* _tmp7_;
	gchar* _tmp8_;
	g_return_val_if_fail (key != NULL, NULL);
	_tmp0_ = key;
	_tmp1_ = key_get_value (_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = _tmp2_;
	_tmp4_ = key;
	_tmp5_ = key_get_type_string (_tmp4_);
	_tmp6_ = _tmp5_;
	_tmp7_ = key_cool_text_value_from_variant (_tmp3_, _tmp6_);
	_tmp8_ = _tmp7_;
	_g_variant_unref0 (_tmp3_);
	result = _tmp8_;
	return result;
}


static void key_list_box_row_real_update (KeyListBoxRow* self) {
	g_critical ("Type `%s' does not implement abstract method `key_list_box_row_update'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return;
}


void key_list_box_row_update (KeyListBoxRow* self) {
	g_return_if_fail (self != NULL);
	KEY_LIST_BOX_ROW_GET_CLASS (self)->update (self);
}


KeyListBoxRow* key_list_box_row_construct (GType object_type) {
	KeyListBoxRow * self = NULL;
	self = (KeyListBoxRow*) clickable_list_box_row_construct (object_type);
	return self;
}


static Key* key_list_box_row_get_abstract_key (KeyListBoxRow* self) {
	g_return_val_if_fail (self != NULL, NULL);
	return KEY_LIST_BOX_ROW_GET_CLASS (self)->get_abstract_key (self);
}


static void g_cclosure_user_marshal_VOID__VARIANT (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef void (*GMarshalFunc_VOID__VARIANT) (gpointer data1, gpointer arg_1, gpointer data2);
	register GMarshalFunc_VOID__VARIANT callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 2);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__VARIANT) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_variant (param_values + 1), data2);
}


static Block11Data* block11_data_ref (Block11Data* _data11_) {
	g_atomic_int_inc (&_data11_->_ref_count_);
	return _data11_;
}


static void block11_data_unref (void * _userdata_) {
	Block11Data* _data11_;
	_data11_ = (Block11Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data11_->_ref_count_)) {
		KeyListBoxRow* self;
		self = _data11_->self;
		_g_object_unref0 (self);
		g_slice_free (Block11Data, _data11_);
	}
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void _key_list_box_row___lambda58_ (KeyListBoxRow* self) {
	key_list_box_row_update (self);
	clickable_list_box_row_destroy_popover ((ClickableListBoxRow*) self);
}


static void __key_list_box_row___lambda58__key_value_changed (Key* _sender, gpointer self) {
	_key_list_box_row___lambda58_ ((KeyListBoxRow*) self);
}


static void _key_list_box_row___lambda59_ (Block11Data* _data11_) {
	KeyListBoxRow* self;
	Key* _tmp0_;
	Key* _tmp1_;
	gulong _tmp2_;
	self = _data11_->self;
	_tmp0_ = key_list_box_row_get_abstract_key (self);
	_tmp1_ = _tmp0_;
	_tmp2_ = _data11_->key_value_changed_handler;
	g_signal_handler_disconnect ((GObject*) _tmp1_, _tmp2_);
}


static void __key_list_box_row___lambda59__gtk_widget_destroy (GtkWidget* _sender, gpointer self) {
	_key_list_box_row___lambda59_ (self);
}


static GObject * key_list_box_row_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	KeyListBoxRow * self;
	Block11Data* _data11_;
	GtkLabel* _tmp0_;
	GtkStyleContext* _tmp1_;
	GtkStyleContext* _tmp2_;
	GtkLabel* _tmp3_;
	GtkStyleContext* _tmp4_;
	GtkStyleContext* _tmp5_;
	GtkLabel* _tmp6_;
	Key* _tmp7_;
	Key* _tmp8_;
	const gchar* _tmp9_;
	const gchar* _tmp10_;
	Key* _tmp11_;
	Key* _tmp12_;
	gulong _tmp13_;
	parent_class = G_OBJECT_CLASS (key_list_box_row_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_KEY_LIST_BOX_ROW, KeyListBoxRow);
	_data11_ = g_slice_new0 (Block11Data);
	_data11_->_ref_count_ = 1;
	_data11_->self = g_object_ref (self);
	_tmp0_ = self->priv->key_name_label;
	_tmp1_ = gtk_widget_get_style_context ((GtkWidget*) _tmp0_);
	_tmp2_ = _g_object_ref0 (_tmp1_);
	_g_object_unref0 (self->name_context);
	self->name_context = _tmp2_;
	_tmp3_ = self->key_value_label;
	_tmp4_ = gtk_widget_get_style_context ((GtkWidget*) _tmp3_);
	_tmp5_ = _g_object_ref0 (_tmp4_);
	_g_object_unref0 (self->value_context);
	self->value_context = _tmp5_;
	key_list_box_row_update (self);
	_tmp6_ = self->priv->key_name_label;
	_tmp7_ = key_list_box_row_get_abstract_key (self);
	_tmp8_ = _tmp7_;
	_tmp9_ = setting_object_get_name ((SettingObject*) _tmp8_);
	_tmp10_ = _tmp9_;
	gtk_label_set_label (_tmp6_, _tmp10_);
	_tmp11_ = key_list_box_row_get_abstract_key (self);
	_tmp12_ = _tmp11_;
	_tmp13_ = g_signal_connect_object (_tmp12_, "value-changed", (GCallback) __key_list_box_row___lambda58__key_value_changed, self, 0);
	_data11_->key_value_changed_handler = _tmp13_;
	g_signal_connect_data ((GtkWidget*) self, "destroy", (GCallback) __key_list_box_row___lambda59__gtk_widget_destroy, block11_data_ref (_data11_), (GClosureNotify) block11_data_unref, 0);
	block11_data_unref (_data11_);
	_data11_ = NULL;
	return obj;
}


static void key_list_box_row_class_init (KeyListBoxRowClass * klass) {
	gint KeyListBoxRow_private_offset;
	key_list_box_row_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (KeyListBoxRowPrivate));
	((KeyListBoxRowClass *) klass)->update = key_list_box_row_real_update;
	G_OBJECT_CLASS (klass)->get_property = _vala_key_list_box_row_get_property;
	G_OBJECT_CLASS (klass)->constructor = key_list_box_row_constructor;
	G_OBJECT_CLASS (klass)->finalize = key_list_box_row_finalize;
	KeyListBoxRow_private_offset = g_type_class_get_instance_private_offset (klass);
	gtk_widget_class_set_template_from_resource (GTK_WIDGET_CLASS (klass), "/ca/desrt/dconf-editor/ui/key-list-box-row.ui");
	key_list_box_row_signals[KEY_LIST_BOX_ROW_SET_KEY_VALUE_SIGNAL] = g_signal_new ("set_key_value", TYPE_KEY_LIST_BOX_ROW, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__VARIANT, G_TYPE_NONE, 1, G_TYPE_VARIANT);
	key_list_box_row_signals[KEY_LIST_BOX_ROW_CHANGE_DISMISSED_SIGNAL] = g_signal_new ("change_dismissed", TYPE_KEY_LIST_BOX_ROW, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "key_name_label", FALSE, KeyListBoxRow_private_offset + G_STRUCT_OFFSET (KeyListBoxRowPrivate, key_name_label));
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "key_value_label", FALSE, G_STRUCT_OFFSET (KeyListBoxRow, key_value_label));
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "key_info_label", FALSE, G_STRUCT_OFFSET (KeyListBoxRow, key_info_label));
}


static void key_list_box_row_instance_init (KeyListBoxRow * self) {
	self->priv = KEY_LIST_BOX_ROW_GET_PRIVATE (self);
	gtk_widget_init_template (GTK_WIDGET (self));
}


static void key_list_box_row_finalize (GObject * obj) {
	KeyListBoxRow * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_KEY_LIST_BOX_ROW, KeyListBoxRow);
	_g_object_unref0 (self->priv->key_name_label);
	_g_object_unref0 (self->key_value_label);
	_g_object_unref0 (self->key_info_label);
	_g_object_unref0 (self->name_context);
	_g_object_unref0 (self->value_context);
	G_OBJECT_CLASS (key_list_box_row_parent_class)->finalize (obj);
}


GType key_list_box_row_get_type (void) {
	static volatile gsize key_list_box_row_type_id__volatile = 0;
	if (g_once_init_enter (&key_list_box_row_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (KeyListBoxRowClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) key_list_box_row_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (KeyListBoxRow), 0, (GInstanceInitFunc) key_list_box_row_instance_init, NULL };
		GType key_list_box_row_type_id;
		key_list_box_row_type_id = g_type_register_static (TYPE_CLICKABLE_LIST_BOX_ROW, "KeyListBoxRow", &g_define_type_info, G_TYPE_FLAG_ABSTRACT);
		g_once_init_leave (&key_list_box_row_type_id__volatile, key_list_box_row_type_id);
	}
	return key_list_box_row_type_id__volatile;
}


static void _vala_key_list_box_row_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	KeyListBoxRow * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_KEY_LIST_BOX_ROW, KeyListBoxRow);
	switch (property_id) {
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


KeyListBoxRowEditableNoSchema* key_list_box_row_editable_no_schema_construct (GType object_type, DConfKey* _key) {
	KeyListBoxRowEditableNoSchema * self = NULL;
	DConfKey* _tmp0_;
	GtkLabel* _tmp1_;
	GtkStyleContext* _tmp2_;
	GtkLabel* _tmp3_;
	g_return_val_if_fail (_key != NULL, NULL);
	_tmp0_ = _key;
	self = (KeyListBoxRowEditableNoSchema*) g_object_new (object_type, "key", _tmp0_, NULL);
	_tmp1_ = ((KeyListBoxRow*) self)->key_info_label;
	_tmp2_ = gtk_widget_get_style_context ((GtkWidget*) _tmp1_);
	gtk_style_context_add_class (_tmp2_, "italic-label");
	_tmp3_ = ((KeyListBoxRow*) self)->key_info_label;
	gtk_label_set_label (_tmp3_, _ ("No Schema Found"));
	return self;
}


KeyListBoxRowEditableNoSchema* key_list_box_row_editable_no_schema_new (DConfKey* _key) {
	return key_list_box_row_editable_no_schema_construct (TYPE_KEY_LIST_BOX_ROW_EDITABLE_NO_SCHEMA, _key);
}


static void key_list_box_row_editable_no_schema_real_update (KeyListBoxRow* base) {
	KeyListBoxRowEditableNoSchema * self;
	DConfKey* _tmp0_;
	gboolean _tmp1_;
	gboolean _tmp2_;
	self = (KeyListBoxRowEditableNoSchema*) base;
	_tmp0_ = self->priv->_key;
	_tmp1_ = dconf_key_get_is_ghost (_tmp0_);
	_tmp2_ = _tmp1_;
	if (_tmp2_) {
		GtkStyleContext* _tmp3_;
		gboolean _tmp4_;
		GtkStyleContext* _tmp6_;
		gboolean _tmp7_;
		GtkLabel* _tmp9_;
		GtkStyleContext* _tmp10_;
		gboolean _tmp11_;
		_tmp3_ = ((KeyListBoxRow*) self)->value_context;
		_tmp4_ = gtk_style_context_has_class (_tmp3_, "italic-label");
		if (!_tmp4_) {
			GtkStyleContext* _tmp5_;
			_tmp5_ = ((KeyListBoxRow*) self)->value_context;
			gtk_style_context_add_class (_tmp5_, "italic-label");
		}
		_tmp6_ = ((KeyListBoxRow*) self)->value_context;
		_tmp7_ = gtk_style_context_has_class (_tmp6_, "bold-label");
		if (_tmp7_) {
			GtkStyleContext* _tmp8_;
			_tmp8_ = ((KeyListBoxRow*) self)->value_context;
			gtk_style_context_remove_class (_tmp8_, "bold-label");
		}
		_tmp9_ = ((KeyListBoxRow*) self)->key_value_label;
		gtk_label_set_label (_tmp9_, _ ("Key erased."));
		_tmp10_ = ((KeyListBoxRow*) self)->name_context;
		_tmp11_ = gtk_style_context_has_class (_tmp10_, "bold-label");
		if (_tmp11_) {
			GtkStyleContext* _tmp12_;
			_tmp12_ = ((KeyListBoxRow*) self)->name_context;
			gtk_style_context_remove_class (_tmp12_, "bold-label");
		}
	} else {
		GtkStyleContext* _tmp13_;
		gboolean _tmp14_;
		GtkStyleContext* _tmp16_;
		gboolean _tmp17_;
		GtkLabel* _tmp19_;
		DConfKey* _tmp20_;
		gchar* _tmp21_;
		gchar* _tmp22_;
		GtkStyleContext* _tmp23_;
		gboolean _tmp24_;
		_tmp13_ = ((KeyListBoxRow*) self)->value_context;
		_tmp14_ = gtk_style_context_has_class (_tmp13_, "italic-label");
		if (_tmp14_) {
			GtkStyleContext* _tmp15_;
			_tmp15_ = ((KeyListBoxRow*) self)->value_context;
			gtk_style_context_remove_class (_tmp15_, "italic-label");
		}
		_tmp16_ = ((KeyListBoxRow*) self)->value_context;
		_tmp17_ = gtk_style_context_has_class (_tmp16_, "bold-label");
		if (!_tmp17_) {
			GtkStyleContext* _tmp18_;
			_tmp18_ = ((KeyListBoxRow*) self)->value_context;
			gtk_style_context_add_class (_tmp18_, "bold-label");
		}
		_tmp19_ = ((KeyListBoxRow*) self)->key_value_label;
		_tmp20_ = self->priv->_key;
		_tmp21_ = key_list_box_row_cool_text_value ((Key*) _tmp20_);
		_tmp22_ = _tmp21_;
		gtk_label_set_label (_tmp19_, _tmp22_);
		g_free (_tmp22_);
		_tmp23_ = ((KeyListBoxRow*) self)->name_context;
		_tmp24_ = gtk_style_context_has_class (_tmp23_, "bold-label");
		if (!_tmp24_) {
			GtkStyleContext* _tmp25_;
			_tmp25_ = ((KeyListBoxRow*) self)->name_context;
			gtk_style_context_add_class (_tmp25_, "bold-label");
		}
	}
}


static gchar* key_list_box_row_editable_no_schema_real_get_text (ClickableListBoxRow* base) {
	KeyListBoxRowEditableNoSchema * self;
	gchar* result = NULL;
	gchar* _tmp0_ = NULL;
	DConfKey* _tmp1_;
	gboolean _tmp2_;
	gboolean _tmp3_;
	self = (KeyListBoxRowEditableNoSchema*) base;
	_tmp1_ = self->priv->_key;
	_tmp2_ = dconf_key_get_is_ghost (_tmp1_);
	_tmp3_ = _tmp2_;
	if (_tmp3_) {
		DConfKey* _tmp4_;
		const gchar* _tmp5_;
		const gchar* _tmp6_;
		gchar* _tmp7_;
		_tmp4_ = self->priv->_key;
		_tmp5_ = setting_object_get_full_name ((SettingObject*) _tmp4_);
		_tmp6_ = _tmp5_;
		_tmp7_ = g_strdup_printf (_ ("%s (key erased)"), _tmp6_);
		g_free (_tmp0_);
		_tmp0_ = _tmp7_;
	} else {
		DConfKey* _tmp8_;
		gchar* _tmp9_;
		gchar* _tmp10_;
		gchar* _tmp11_;
		gchar* _tmp12_;
		gchar* _tmp13_;
		DConfKey* _tmp14_;
		GVariant* _tmp15_;
		GVariant* _tmp16_;
		GVariant* _tmp17_;
		gchar* _tmp18_;
		gchar* _tmp19_;
		gchar* _tmp20_;
		_tmp8_ = self->priv->_key;
		_tmp9_ = key_get_descriptor ((Key*) _tmp8_);
		_tmp10_ = _tmp9_;
		_tmp11_ = _tmp10_;
		_tmp12_ = g_strconcat (_tmp11_, " ", NULL);
		_tmp13_ = _tmp12_;
		_tmp14_ = self->priv->_key;
		_tmp15_ = key_get_value ((Key*) _tmp14_);
		_tmp16_ = _tmp15_;
		_tmp17_ = _tmp16_;
		_tmp18_ = g_variant_print (_tmp17_, FALSE);
		_tmp19_ = _tmp18_;
		_tmp20_ = g_strconcat (_tmp13_, _tmp19_, NULL);
		g_free (_tmp0_);
		_tmp0_ = _tmp20_;
		g_free (_tmp19_);
		_g_variant_unref0 (_tmp17_);
		g_free (_tmp13_);
		g_free (_tmp11_);
	}
	result = _tmp0_;
	return result;
}


static void __lambda68_ (KeyListBoxRowEditableNoSchema* self) {
	g_signal_emit ((ClickableListBoxRow*) self, clickable_list_box_row_signals[CLICKABLE_LIST_BOX_ROW_ON_ROW_CLICKED_SIGNAL], 0);
}


static void ___lambda68__contextpopoverbutton_action (gpointer self) {
	__lambda68_ ((KeyListBoxRowEditableNoSchema*) self);
}


static Block12Data* block12_data_ref (Block12Data* _data12_) {
	g_atomic_int_inc (&_data12_->_ref_count_);
	return _data12_;
}


static void block12_data_unref (void * _userdata_) {
	Block12Data* _data12_;
	_data12_ = (Block12Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data12_->_ref_count_)) {
		KeyListBoxRowEditableNoSchema* self;
		self = _data12_->self;
		_g_object_unref0 (_data12_->action);
		_g_object_unref0 (self);
		g_slice_free (Block12Data, _data12_);
	}
}


static void ___lambda69_ (KeyListBoxRowEditableNoSchema* self) {
	clickable_list_box_row_destroy_popover ((ClickableListBoxRow*) self);
	g_signal_emit ((KeyListBoxRow*) self, key_list_box_row_signals[KEY_LIST_BOX_ROW_CHANGE_DISMISSED_SIGNAL], 0);
}


static void ____lambda69__context_popover_change_dismissed (ContextPopover* _sender, gpointer self) {
	___lambda69_ ((KeyListBoxRowEditableNoSchema*) self);
}


static void ___lambda70_ (Block12Data* _data12_, GVariant* gvariant) {
	KeyListBoxRowEditableNoSchema* self;
	GAction* _tmp0_;
	DConfKey* _tmp1_;
	const gchar* _tmp2_;
	const gchar* _tmp3_;
	GVariantType* _tmp4_;
	GVariantType* _tmp5_;
	GVariant* _tmp6_;
	GVariant* _tmp7_;
	GVariant* _tmp8_;
	GVariant* _tmp9_;
	GVariant* _tmp10_;
	GVariant* _tmp11_;
	self = _data12_->self;
	clickable_list_box_row_hide_right_click_popover ((ClickableListBoxRow*) self);
	_tmp0_ = _data12_->action;
	_tmp1_ = self->priv->_key;
	_tmp2_ = key_get_type_string ((Key*) _tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = g_variant_type_new (_tmp3_);
	_tmp5_ = _tmp4_;
	_tmp6_ = gvariant;
	_tmp7_ = g_variant_new_maybe (_tmp5_, _tmp6_);
	g_variant_ref_sink (_tmp7_);
	_tmp8_ = _tmp7_;
	_tmp9_ = g_variant_new_maybe (NULL, _tmp8_);
	g_variant_ref_sink (_tmp9_);
	_tmp10_ = _tmp9_;
	g_action_change_state (_tmp0_, _tmp10_);
	_g_variant_unref0 (_tmp10_);
	_g_variant_unref0 (_tmp8_);
	_g_variant_type_free0 (_tmp5_);
	_tmp11_ = gvariant;
	g_signal_emit ((KeyListBoxRow*) self, key_list_box_row_signals[KEY_LIST_BOX_ROW_SET_KEY_VALUE_SIGNAL], 0, _tmp11_);
}


static void ____lambda70__context_popover_value_changed (ContextPopover* _sender, GVariant* gvariant, gpointer self) {
	___lambda70_ (self, gvariant);
}


static void ____lambda71_ (KeyListBoxRowEditableNoSchema* self) {
	clickable_list_box_row_destroy_popover ((ClickableListBoxRow*) self);
	g_signal_emit ((KeyListBoxRow*) self, key_list_box_row_signals[KEY_LIST_BOX_ROW_SET_KEY_VALUE_SIGNAL], 0, NULL);
}


static void _____lambda71__contextpopoverbutton_action (gpointer self) {
	____lambda71_ ((KeyListBoxRowEditableNoSchema*) self);
}


static void ____lambda72_ (KeyListBoxRowEditableNoSchema* self) {
	clickable_list_box_row_destroy_popover ((ClickableListBoxRow*) self);
	g_signal_emit ((KeyListBoxRow*) self, key_list_box_row_signals[KEY_LIST_BOX_ROW_CHANGE_DISMISSED_SIGNAL], 0);
}


static void _____lambda72__contextpopoverbutton_action (gpointer self) {
	____lambda72_ ((KeyListBoxRowEditableNoSchema*) self);
}


static void ____lambda73_ (KeyListBoxRowEditableNoSchema* self) {
	clickable_list_box_row_destroy_popover ((ClickableListBoxRow*) self);
	g_signal_emit ((KeyListBoxRow*) self, key_list_box_row_signals[KEY_LIST_BOX_ROW_SET_KEY_VALUE_SIGNAL], 0, NULL);
}


static void _____lambda73__contextpopoverbutton_action (gpointer self) {
	____lambda73_ ((KeyListBoxRowEditableNoSchema*) self);
}


static gboolean key_list_box_row_editable_no_schema_real_generate_popover (ClickableListBoxRow* base, ContextPopover* popover, gboolean delayed_apply_menu) {
	KeyListBoxRowEditableNoSchema * self;
	gboolean result = FALSE;
	DConfKey* _tmp0_;
	gboolean _tmp1_;
	gboolean _tmp2_;
	ContextPopover* _tmp6_;
	ContextPopover* _tmp7_;
	gchar* _tmp8_;
	gchar* _tmp9_;
	gboolean _tmp10_ = FALSE;
	DConfKey* _tmp11_;
	const gchar* _tmp12_;
	const gchar* _tmp13_;
	self = (KeyListBoxRowEditableNoSchema*) base;
	g_return_val_if_fail (popover != NULL, FALSE);
	_tmp0_ = self->priv->_key;
	_tmp1_ = dconf_key_get_is_ghost (_tmp0_);
	_tmp2_ = _tmp1_;
	if (_tmp2_) {
		ContextPopover* _tmp3_;
		gchar* _tmp4_;
		gchar* _tmp5_;
		_tmp3_ = popover;
		_tmp4_ = clickable_list_box_row_get_text ((ClickableListBoxRow*) self);
		_tmp5_ = _tmp4_;
		context_popover_new_copy_action (_tmp3_, _tmp5_);
		g_free (_tmp5_);
		result = TRUE;
		return result;
	}
	_tmp6_ = popover;
	context_popover_new_action (_tmp6_, "customize", ___lambda68__contextpopoverbutton_action, self);
	_tmp7_ = popover;
	_tmp8_ = clickable_list_box_row_get_text ((ClickableListBoxRow*) self);
	_tmp9_ = _tmp8_;
	context_popover_new_copy_action (_tmp7_, _tmp9_);
	g_free (_tmp9_);
	_tmp11_ = self->priv->_key;
	_tmp12_ = key_get_type_string ((Key*) _tmp11_);
	_tmp13_ = _tmp12_;
	if (g_strcmp0 (_tmp13_, "b") == 0) {
		_tmp10_ = TRUE;
	} else {
		DConfKey* _tmp14_;
		const gchar* _tmp15_;
		const gchar* _tmp16_;
		_tmp14_ = self->priv->_key;
		_tmp15_ = key_get_type_string ((Key*) _tmp14_);
		_tmp16_ = _tmp15_;
		_tmp10_ = g_strcmp0 (_tmp16_, "mb") == 0;
	}
	if (_tmp10_) {
		Block12Data* _data12_;
		ContextPopover* _tmp17_;
		ContextPopover* _tmp18_;
		DConfKey* _tmp19_;
		gboolean _tmp20_;
		GAction* _tmp21_;
		ContextPopover* _tmp22_;
		ContextPopover* _tmp23_;
		gboolean _tmp24_;
		_data12_ = g_slice_new0 (Block12Data);
		_data12_->_ref_count_ = 1;
		_data12_->self = g_object_ref (self);
		_tmp17_ = popover;
		context_popover_new_section (_tmp17_);
		_tmp18_ = popover;
		_tmp19_ = self->priv->_key;
		_tmp20_ = delayed_apply_menu;
		_tmp21_ = context_popover_create_buttons_list (_tmp18_, (Key*) _tmp19_, TRUE, _tmp20_);
		_data12_->action = _tmp21_;
		_tmp22_ = popover;
		g_signal_connect_object (_tmp22_, "change-dismissed", (GCallback) ____lambda69__context_popover_change_dismissed, self, 0);
		_tmp23_ = popover;
		g_signal_connect_data (_tmp23_, "value-changed", (GCallback) ____lambda70__context_popover_value_changed, block12_data_ref (_data12_), (GClosureNotify) block12_data_unref, 0);
		_tmp24_ = delayed_apply_menu;
		if (!_tmp24_) {
			ContextPopover* _tmp25_;
			ContextPopover* _tmp26_;
			_tmp25_ = popover;
			context_popover_new_section (_tmp25_);
			_tmp26_ = popover;
			context_popover_new_action (_tmp26_, "erase", _____lambda71__contextpopoverbutton_action, self);
		}
		block12_data_unref (_data12_);
		_data12_ = NULL;
	} else {
		DConfKey* _tmp27_;
		gboolean _tmp28_;
		gboolean _tmp29_;
		gboolean _tmp36_ = FALSE;
		DConfKey* _tmp37_;
		gboolean _tmp38_;
		gboolean _tmp39_;
		_tmp27_ = self->priv->_key;
		_tmp28_ = key_get_planned_change ((Key*) _tmp27_);
		_tmp29_ = _tmp28_;
		if (_tmp29_) {
			ContextPopover* _tmp30_;
			const gchar* _tmp31_ = NULL;
			DConfKey* _tmp32_;
			GVariant* _tmp33_;
			GVariant* _tmp34_;
			ContextPopover* _tmp35_;
			_tmp30_ = popover;
			context_popover_new_section (_tmp30_);
			_tmp32_ = self->priv->_key;
			_tmp33_ = key_get_planned_value ((Key*) _tmp32_);
			_tmp34_ = _tmp33_;
			if (_tmp34_ == NULL) {
				_tmp31_ = "unerase";
			} else {
				_tmp31_ = "dismiss";
			}
			_tmp35_ = popover;
			context_popover_new_action (_tmp35_, _tmp31_, _____lambda72__contextpopoverbutton_action, self);
		}
		_tmp37_ = self->priv->_key;
		_tmp38_ = key_get_planned_change ((Key*) _tmp37_);
		_tmp39_ = _tmp38_;
		if (!_tmp39_) {
			_tmp36_ = TRUE;
		} else {
			DConfKey* _tmp40_;
			GVariant* _tmp41_;
			GVariant* _tmp42_;
			_tmp40_ = self->priv->_key;
			_tmp41_ = key_get_planned_value ((Key*) _tmp40_);
			_tmp42_ = _tmp41_;
			_tmp36_ = _tmp42_ != NULL;
		}
		if (_tmp36_) {
			ContextPopover* _tmp43_;
			ContextPopover* _tmp44_;
			_tmp43_ = popover;
			context_popover_new_section (_tmp43_);
			_tmp44_ = popover;
			context_popover_new_action (_tmp44_, "erase", _____lambda73__contextpopoverbutton_action, self);
		}
	}
	result = TRUE;
	return result;
}


DConfKey* key_list_box_row_editable_no_schema_get_key (KeyListBoxRowEditableNoSchema* self) {
	DConfKey* result;
	DConfKey* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_key;
	result = _tmp0_;
	return result;
}


static void key_list_box_row_editable_no_schema_set_key (KeyListBoxRowEditableNoSchema* self, DConfKey* value) {
	g_return_if_fail (self != NULL);
	if (key_list_box_row_editable_no_schema_get_key (self) != value) {
		DConfKey* _tmp0_;
		DConfKey* _tmp1_;
		_tmp0_ = value;
		_tmp1_ = _g_object_ref0 (_tmp0_);
		_g_object_unref0 (self->priv->_key);
		self->priv->_key = _tmp1_;
		g_object_notify ((GObject *) self, "key");
	}
}


static Key* key_list_box_row_editable_no_schema_real_get_abstract_key (KeyListBoxRow* base) {
	Key* result;
	KeyListBoxRowEditableNoSchema* self;
	DConfKey* _tmp0_;
	self = (KeyListBoxRowEditableNoSchema*) base;
	_tmp0_ = self->priv->_key;
	result = G_TYPE_CHECK_INSTANCE_CAST (_tmp0_, TYPE_KEY, Key);
	return result;
}


static void key_list_box_row_editable_no_schema_class_init (KeyListBoxRowEditableNoSchemaClass * klass) {
	key_list_box_row_editable_no_schema_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (KeyListBoxRowEditableNoSchemaPrivate));
	((KeyListBoxRowClass *) klass)->update = key_list_box_row_editable_no_schema_real_update;
	((ClickableListBoxRowClass *) klass)->get_text = key_list_box_row_editable_no_schema_real_get_text;
	((ClickableListBoxRowClass *) klass)->generate_popover = key_list_box_row_editable_no_schema_real_generate_popover;
	KEY_LIST_BOX_ROW_CLASS (klass)->get_abstract_key = key_list_box_row_editable_no_schema_real_get_abstract_key;
	G_OBJECT_CLASS (klass)->get_property = _vala_key_list_box_row_editable_no_schema_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_key_list_box_row_editable_no_schema_set_property;
	G_OBJECT_CLASS (klass)->finalize = key_list_box_row_editable_no_schema_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), KEY_LIST_BOX_ROW_EDITABLE_NO_SCHEMA_KEY, g_param_spec_object ("key", "key", "key", TYPE_DCONF_KEY, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
}


static void key_list_box_row_editable_no_schema_instance_init (KeyListBoxRowEditableNoSchema * self) {
	self->priv = KEY_LIST_BOX_ROW_EDITABLE_NO_SCHEMA_GET_PRIVATE (self);
}


static void key_list_box_row_editable_no_schema_finalize (GObject * obj) {
	KeyListBoxRowEditableNoSchema * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_KEY_LIST_BOX_ROW_EDITABLE_NO_SCHEMA, KeyListBoxRowEditableNoSchema);
	_g_object_unref0 (self->priv->_key);
	G_OBJECT_CLASS (key_list_box_row_editable_no_schema_parent_class)->finalize (obj);
}


GType key_list_box_row_editable_no_schema_get_type (void) {
	static volatile gsize key_list_box_row_editable_no_schema_type_id__volatile = 0;
	if (g_once_init_enter (&key_list_box_row_editable_no_schema_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (KeyListBoxRowEditableNoSchemaClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) key_list_box_row_editable_no_schema_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (KeyListBoxRowEditableNoSchema), 0, (GInstanceInitFunc) key_list_box_row_editable_no_schema_instance_init, NULL };
		GType key_list_box_row_editable_no_schema_type_id;
		key_list_box_row_editable_no_schema_type_id = g_type_register_static (TYPE_KEY_LIST_BOX_ROW, "KeyListBoxRowEditableNoSchema", &g_define_type_info, 0);
		g_once_init_leave (&key_list_box_row_editable_no_schema_type_id__volatile, key_list_box_row_editable_no_schema_type_id);
	}
	return key_list_box_row_editable_no_schema_type_id__volatile;
}


static void _vala_key_list_box_row_editable_no_schema_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	KeyListBoxRowEditableNoSchema * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_KEY_LIST_BOX_ROW_EDITABLE_NO_SCHEMA, KeyListBoxRowEditableNoSchema);
	switch (property_id) {
		case KEY_LIST_BOX_ROW_EDITABLE_NO_SCHEMA_KEY:
		g_value_set_object (value, key_list_box_row_editable_no_schema_get_key (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_key_list_box_row_editable_no_schema_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	KeyListBoxRowEditableNoSchema * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_KEY_LIST_BOX_ROW_EDITABLE_NO_SCHEMA, KeyListBoxRowEditableNoSchema);
	switch (property_id) {
		case KEY_LIST_BOX_ROW_EDITABLE_NO_SCHEMA_KEY:
		key_list_box_row_editable_no_schema_set_key (self, g_value_get_object (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


KeyListBoxRowEditable* key_list_box_row_editable_construct (GType object_type, GSettingsKey* _key) {
	KeyListBoxRowEditable * self = NULL;
	GSettingsKey* _tmp0_;
	GtkLabel* _tmp1_;
	GSettingsKey* _tmp2_;
	const gchar* _tmp3_;
	const gchar* _tmp4_;
	g_return_val_if_fail (_key != NULL, NULL);
	_tmp0_ = _key;
	self = (KeyListBoxRowEditable*) g_object_new (object_type, "key", _tmp0_, NULL);
	_tmp1_ = ((KeyListBoxRow*) self)->key_info_label;
	_tmp2_ = self->priv->_key;
	_tmp3_ = gsettings_key_get_summary (_tmp2_);
	_tmp4_ = _tmp3_;
	gtk_label_set_label (_tmp1_, _tmp4_);
	return self;
}


KeyListBoxRowEditable* key_list_box_row_editable_new (GSettingsKey* _key) {
	return key_list_box_row_editable_construct (TYPE_KEY_LIST_BOX_ROW_EDITABLE, _key);
}


static void key_list_box_row_editable_real_update (KeyListBoxRow* base) {
	KeyListBoxRowEditable * self;
	GSettingsKey* _tmp0_;
	gboolean _tmp1_;
	gboolean _tmp2_;
	GtkLabel* _tmp15_;
	GSettingsKey* _tmp16_;
	gchar* _tmp17_;
	gchar* _tmp18_;
	self = (KeyListBoxRowEditable*) base;
	_tmp0_ = self->priv->_key;
	_tmp1_ = gsettings_key_get_is_default (_tmp0_);
	_tmp2_ = _tmp1_;
	if (_tmp2_) {
		GtkStyleContext* _tmp3_;
		gboolean _tmp4_;
		GtkStyleContext* _tmp6_;
		gboolean _tmp7_;
		_tmp3_ = ((KeyListBoxRow*) self)->name_context;
		_tmp4_ = gtk_style_context_has_class (_tmp3_, "bold-label");
		if (_tmp4_) {
			GtkStyleContext* _tmp5_;
			_tmp5_ = ((KeyListBoxRow*) self)->name_context;
			gtk_style_context_remove_class (_tmp5_, "bold-label");
		}
		_tmp6_ = ((KeyListBoxRow*) self)->value_context;
		_tmp7_ = gtk_style_context_has_class (_tmp6_, "bold-label");
		if (_tmp7_) {
			GtkStyleContext* _tmp8_;
			_tmp8_ = ((KeyListBoxRow*) self)->value_context;
			gtk_style_context_remove_class (_tmp8_, "bold-label");
		}
	} else {
		GtkStyleContext* _tmp9_;
		gboolean _tmp10_;
		GtkStyleContext* _tmp12_;
		gboolean _tmp13_;
		_tmp9_ = ((KeyListBoxRow*) self)->name_context;
		_tmp10_ = gtk_style_context_has_class (_tmp9_, "bold-label");
		if (!_tmp10_) {
			GtkStyleContext* _tmp11_;
			_tmp11_ = ((KeyListBoxRow*) self)->name_context;
			gtk_style_context_add_class (_tmp11_, "bold-label");
		}
		_tmp12_ = ((KeyListBoxRow*) self)->value_context;
		_tmp13_ = gtk_style_context_has_class (_tmp12_, "bold-label");
		if (!_tmp13_) {
			GtkStyleContext* _tmp14_;
			_tmp14_ = ((KeyListBoxRow*) self)->value_context;
			gtk_style_context_add_class (_tmp14_, "bold-label");
		}
	}
	_tmp15_ = ((KeyListBoxRow*) self)->key_value_label;
	_tmp16_ = self->priv->_key;
	_tmp17_ = key_list_box_row_cool_text_value ((Key*) _tmp16_);
	_tmp18_ = _tmp17_;
	gtk_label_set_label (_tmp15_, _tmp18_);
	g_free (_tmp18_);
}


static gchar* key_list_box_row_editable_real_get_text (ClickableListBoxRow* base) {
	KeyListBoxRowEditable * self;
	gchar* result = NULL;
	GSettingsKey* _tmp0_;
	gchar* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	gchar* _tmp4_;
	gchar* _tmp5_;
	GSettingsKey* _tmp6_;
	GVariant* _tmp7_;
	GVariant* _tmp8_;
	GVariant* _tmp9_;
	gchar* _tmp10_;
	gchar* _tmp11_;
	gchar* _tmp12_;
	gchar* _tmp13_;
	self = (KeyListBoxRowEditable*) base;
	_tmp0_ = self->priv->_key;
	_tmp1_ = key_get_descriptor ((Key*) _tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = _tmp2_;
	_tmp4_ = g_strconcat (_tmp3_, " ", NULL);
	_tmp5_ = _tmp4_;
	_tmp6_ = self->priv->_key;
	_tmp7_ = key_get_value ((Key*) _tmp6_);
	_tmp8_ = _tmp7_;
	_tmp9_ = _tmp8_;
	_tmp10_ = g_variant_print (_tmp9_, FALSE);
	_tmp11_ = _tmp10_;
	_tmp12_ = g_strconcat (_tmp5_, _tmp11_, NULL);
	_tmp13_ = _tmp12_;
	g_free (_tmp11_);
	_g_variant_unref0 (_tmp9_);
	g_free (_tmp5_);
	g_free (_tmp3_);
	result = _tmp13_;
	return result;
}


static void __lambda60_ (KeyListBoxRowEditable* self) {
	g_signal_emit ((ClickableListBoxRow*) self, clickable_list_box_row_signals[CLICKABLE_LIST_BOX_ROW_ON_ROW_CLICKED_SIGNAL], 0);
}


static void ___lambda60__contextpopoverbutton_action (gpointer self) {
	__lambda60_ ((KeyListBoxRowEditable*) self);
}


static Block13Data* block13_data_ref (Block13Data* _data13_) {
	g_atomic_int_inc (&_data13_->_ref_count_);
	return _data13_;
}


static void block13_data_unref (void * _userdata_) {
	Block13Data* _data13_;
	_data13_ = (Block13Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data13_->_ref_count_)) {
		KeyListBoxRowEditable* self;
		self = _data13_->self;
		_g_object_unref0 (_data13_->action);
		g_free (_data13_->real_type_string);
		_g_object_unref0 (self);
		g_slice_free (Block13Data, _data13_);
	}
}


static void ___lambda61_ (KeyListBoxRowEditable* self) {
	clickable_list_box_row_destroy_popover ((ClickableListBoxRow*) self);
	g_signal_emit ((KeyListBoxRow*) self, key_list_box_row_signals[KEY_LIST_BOX_ROW_CHANGE_DISMISSED_SIGNAL], 0);
}


static void ____lambda61__context_popover_change_dismissed (ContextPopover* _sender, gpointer self) {
	___lambda61_ ((KeyListBoxRowEditable*) self);
}


static void ___lambda62_ (Block13Data* _data13_, GVariant* gvariant) {
	KeyListBoxRowEditable* self;
	GAction* _tmp0_;
	const gchar* _tmp1_;
	GVariantType* _tmp2_;
	GVariantType* _tmp3_;
	GVariant* _tmp4_;
	GVariant* _tmp5_;
	GVariant* _tmp6_;
	GVariant* _tmp7_;
	GVariant* _tmp8_;
	GVariant* _tmp9_;
	self = _data13_->self;
	clickable_list_box_row_hide_right_click_popover ((ClickableListBoxRow*) self);
	_tmp0_ = _data13_->action;
	_tmp1_ = _data13_->real_type_string;
	_tmp2_ = g_variant_type_new (_tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = gvariant;
	_tmp5_ = g_variant_new_maybe (_tmp3_, _tmp4_);
	g_variant_ref_sink (_tmp5_);
	_tmp6_ = _tmp5_;
	_tmp7_ = g_variant_new_maybe (NULL, _tmp6_);
	g_variant_ref_sink (_tmp7_);
	_tmp8_ = _tmp7_;
	g_action_change_state (_tmp0_, _tmp8_);
	_g_variant_unref0 (_tmp8_);
	_g_variant_unref0 (_tmp6_);
	_g_variant_type_free0 (_tmp3_);
	_tmp9_ = gvariant;
	g_signal_emit ((KeyListBoxRow*) self, key_list_box_row_signals[KEY_LIST_BOX_ROW_SET_KEY_VALUE_SIGNAL], 0, _tmp9_);
}


static void ____lambda62__context_popover_value_changed (ContextPopover* _sender, GVariant* gvariant, gpointer self) {
	___lambda62_ (self, gvariant);
}


static void _____lambda63_ (KeyListBoxRowEditable* self) {
	clickable_list_box_row_destroy_popover ((ClickableListBoxRow*) self);
	g_signal_emit ((KeyListBoxRow*) self, key_list_box_row_signals[KEY_LIST_BOX_ROW_SET_KEY_VALUE_SIGNAL], 0, NULL);
}


static void ______lambda63__contextpopoverbutton_action (gpointer self) {
	_____lambda63_ ((KeyListBoxRowEditable*) self);
}


static void ____lambda64_ (KeyListBoxRowEditable* self, GVariant* gvariant) {
	GVariant* _tmp0_;
	_tmp0_ = gvariant;
	g_signal_emit ((KeyListBoxRow*) self, key_list_box_row_signals[KEY_LIST_BOX_ROW_SET_KEY_VALUE_SIGNAL], 0, _tmp0_);
}


static void _____lambda64__context_popover_value_changed (ContextPopover* _sender, GVariant* gvariant, gpointer self) {
	____lambda64_ ((KeyListBoxRowEditable*) self, gvariant);
}


static void _____lambda65_ (KeyListBoxRowEditable* self) {
	clickable_list_box_row_destroy_popover ((ClickableListBoxRow*) self);
	g_signal_emit ((KeyListBoxRow*) self, key_list_box_row_signals[KEY_LIST_BOX_ROW_CHANGE_DISMISSED_SIGNAL], 0);
}


static void ______lambda65__contextpopoverbutton_action (gpointer self) {
	_____lambda65_ ((KeyListBoxRowEditable*) self);
}


static void ______lambda66_ (KeyListBoxRowEditable* self) {
	clickable_list_box_row_destroy_popover ((ClickableListBoxRow*) self);
	g_signal_emit ((KeyListBoxRow*) self, key_list_box_row_signals[KEY_LIST_BOX_ROW_SET_KEY_VALUE_SIGNAL], 0, NULL);
}


static void _______lambda66__contextpopoverbutton_action (gpointer self) {
	______lambda66_ ((KeyListBoxRowEditable*) self);
}


static void ______lambda67_ (KeyListBoxRowEditable* self) {
	clickable_list_box_row_destroy_popover ((ClickableListBoxRow*) self);
	g_signal_emit ((KeyListBoxRow*) self, key_list_box_row_signals[KEY_LIST_BOX_ROW_SET_KEY_VALUE_SIGNAL], 0, NULL);
}


static void _______lambda67__contextpopoverbutton_action (gpointer self) {
	______lambda67_ ((KeyListBoxRowEditable*) self);
}


static gboolean key_list_box_row_editable_real_generate_popover (ClickableListBoxRow* base, ContextPopover* popover, gboolean delayed_apply_menu) {
	KeyListBoxRowEditable * self;
	gboolean result = FALSE;
	ContextPopover* _tmp0_;
	ContextPopover* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	gboolean _tmp4_ = FALSE;
	gboolean _tmp5_ = FALSE;
	GSettingsKey* _tmp6_;
	const gchar* _tmp7_;
	const gchar* _tmp8_;
	self = (KeyListBoxRowEditable*) base;
	g_return_val_if_fail (popover != NULL, FALSE);
	_tmp0_ = popover;
	context_popover_new_action (_tmp0_, "customize", ___lambda60__contextpopoverbutton_action, self);
	_tmp1_ = popover;
	_tmp2_ = clickable_list_box_row_get_text ((ClickableListBoxRow*) self);
	_tmp3_ = _tmp2_;
	context_popover_new_copy_action (_tmp1_, _tmp3_);
	g_free (_tmp3_);
	_tmp6_ = self->priv->_key;
	_tmp7_ = key_get_type_string ((Key*) _tmp6_);
	_tmp8_ = _tmp7_;
	if (g_strcmp0 (_tmp8_, "b") == 0) {
		_tmp5_ = TRUE;
	} else {
		GSettingsKey* _tmp9_;
		const gchar* _tmp10_;
		const gchar* _tmp11_;
		_tmp9_ = self->priv->_key;
		_tmp10_ = key_get_type_string ((Key*) _tmp9_);
		_tmp11_ = _tmp10_;
		_tmp5_ = g_strcmp0 (_tmp11_, "<enum>") == 0;
	}
	if (_tmp5_) {
		_tmp4_ = TRUE;
	} else {
		GSettingsKey* _tmp12_;
		const gchar* _tmp13_;
		const gchar* _tmp14_;
		_tmp12_ = self->priv->_key;
		_tmp13_ = key_get_type_string ((Key*) _tmp12_);
		_tmp14_ = _tmp13_;
		_tmp4_ = g_strcmp0 (_tmp14_, "mb") == 0;
	}
	if (_tmp4_) {
		Block13Data* _data13_;
		GSettingsKey* _tmp15_;
		GVariant* _tmp16_;
		GVariant* _tmp17_;
		GVariant* _tmp18_;
		const gchar* _tmp19_;
		gchar* _tmp20_;
		gchar* _tmp21_;
		ContextPopover* _tmp22_;
		ContextPopover* _tmp23_;
		GSettingsKey* _tmp24_;
		gboolean _tmp25_;
		GAction* _tmp26_;
		ContextPopover* _tmp27_;
		ContextPopover* _tmp28_;
		_data13_ = g_slice_new0 (Block13Data);
		_data13_->_ref_count_ = 1;
		_data13_->self = g_object_ref (self);
		_tmp15_ = self->priv->_key;
		_tmp16_ = key_get_value ((Key*) _tmp15_);
		_tmp17_ = _tmp16_;
		_tmp18_ = _tmp17_;
		_tmp19_ = g_variant_get_type_string (_tmp18_);
		_tmp20_ = g_strdup (_tmp19_);
		_tmp21_ = _tmp20_;
		_g_variant_unref0 (_tmp18_);
		_data13_->real_type_string = _tmp21_;
		_tmp22_ = popover;
		context_popover_new_section (_tmp22_);
		_tmp23_ = popover;
		_tmp24_ = self->priv->_key;
		_tmp25_ = delayed_apply_menu;
		_tmp26_ = context_popover_create_buttons_list (_tmp23_, (Key*) _tmp24_, TRUE, _tmp25_);
		_data13_->action = _tmp26_;
		_tmp27_ = popover;
		g_signal_connect_object (_tmp27_, "change-dismissed", (GCallback) ____lambda61__context_popover_change_dismissed, self, 0);
		_tmp28_ = popover;
		g_signal_connect_data (_tmp28_, "value-changed", (GCallback) ____lambda62__context_popover_value_changed, block13_data_ref (_data13_), (GClosureNotify) block13_data_unref, 0);
		block13_data_unref (_data13_);
		_data13_ = NULL;
	} else {
		gboolean _tmp29_ = FALSE;
		gboolean _tmp30_ = FALSE;
		gboolean _tmp31_;
		_tmp31_ = delayed_apply_menu;
		if (!_tmp31_) {
			GSettingsKey* _tmp32_;
			gboolean _tmp33_;
			gboolean _tmp34_;
			_tmp32_ = self->priv->_key;
			_tmp33_ = key_get_planned_change ((Key*) _tmp32_);
			_tmp34_ = _tmp33_;
			_tmp30_ = !_tmp34_;
		} else {
			_tmp30_ = FALSE;
		}
		if (_tmp30_) {
			GSettingsKey* _tmp35_;
			const gchar* _tmp36_;
			const gchar* _tmp37_;
			_tmp35_ = self->priv->_key;
			_tmp36_ = key_get_type_string ((Key*) _tmp35_);
			_tmp37_ = _tmp36_;
			_tmp29_ = g_strcmp0 (_tmp37_, "<flags>") == 0;
		} else {
			_tmp29_ = FALSE;
		}
		if (_tmp29_) {
			ContextPopover* _tmp38_;
			GSettingsKey* _tmp39_;
			gboolean _tmp40_;
			gboolean _tmp41_;
			ContextPopover* _tmp43_;
			ContextPopover* _tmp44_;
			GSettingsKey* _tmp45_;
			ContextPopover* _tmp46_;
			_tmp38_ = popover;
			context_popover_new_section (_tmp38_);
			_tmp39_ = self->priv->_key;
			_tmp40_ = gsettings_key_get_is_default (_tmp39_);
			_tmp41_ = _tmp40_;
			if (!_tmp41_) {
				ContextPopover* _tmp42_;
				_tmp42_ = popover;
				context_popover_new_action (_tmp42_, "default2", ______lambda63__contextpopoverbutton_action, self);
			}
			_tmp43_ = popover;
			context_popover_set_group (_tmp43_, "flags");
			_tmp44_ = popover;
			_tmp45_ = self->priv->_key;
			context_popover_create_flags_list (_tmp44_, G_TYPE_CHECK_INSTANCE_CAST (_tmp45_, TYPE_GSETTINGS_KEY, GSettingsKey));
			_tmp46_ = popover;
			g_signal_connect_object (_tmp46_, "value-changed", (GCallback) _____lambda64__context_popover_value_changed, self, 0);
		} else {
			GSettingsKey* _tmp47_;
			gboolean _tmp48_;
			gboolean _tmp49_;
			_tmp47_ = self->priv->_key;
			_tmp48_ = key_get_planned_change ((Key*) _tmp47_);
			_tmp49_ = _tmp48_;
			if (_tmp49_) {
				ContextPopover* _tmp50_;
				ContextPopover* _tmp51_;
				GSettingsKey* _tmp52_;
				GVariant* _tmp53_;
				GVariant* _tmp54_;
				_tmp50_ = popover;
				context_popover_new_section (_tmp50_);
				_tmp51_ = popover;
				context_popover_new_action (_tmp51_, "dismiss", ______lambda65__contextpopoverbutton_action, self);
				_tmp52_ = self->priv->_key;
				_tmp53_ = key_get_planned_value ((Key*) _tmp52_);
				_tmp54_ = _tmp53_;
				if (_tmp54_ != NULL) {
					ContextPopover* _tmp55_;
					_tmp55_ = popover;
					context_popover_new_action (_tmp55_, "default1", _______lambda66__contextpopoverbutton_action, self);
				}
			} else {
				GSettingsKey* _tmp56_;
				gboolean _tmp57_;
				gboolean _tmp58_;
				_tmp56_ = self->priv->_key;
				_tmp57_ = gsettings_key_get_is_default (_tmp56_);
				_tmp58_ = _tmp57_;
				if (!_tmp58_) {
					ContextPopover* _tmp59_;
					ContextPopover* _tmp60_;
					_tmp59_ = popover;
					context_popover_new_section (_tmp59_);
					_tmp60_ = popover;
					context_popover_new_action (_tmp60_, "default1", _______lambda67__contextpopoverbutton_action, self);
				}
			}
		}
	}
	result = TRUE;
	return result;
}


GSettingsKey* key_list_box_row_editable_get_key (KeyListBoxRowEditable* self) {
	GSettingsKey* result;
	GSettingsKey* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_key;
	result = _tmp0_;
	return result;
}


static void key_list_box_row_editable_set_key (KeyListBoxRowEditable* self, GSettingsKey* value) {
	g_return_if_fail (self != NULL);
	if (key_list_box_row_editable_get_key (self) != value) {
		GSettingsKey* _tmp0_;
		GSettingsKey* _tmp1_;
		_tmp0_ = value;
		_tmp1_ = _g_object_ref0 (_tmp0_);
		_g_object_unref0 (self->priv->_key);
		self->priv->_key = _tmp1_;
		g_object_notify ((GObject *) self, "key");
	}
}


static Key* key_list_box_row_editable_real_get_abstract_key (KeyListBoxRow* base) {
	Key* result;
	KeyListBoxRowEditable* self;
	GSettingsKey* _tmp0_;
	self = (KeyListBoxRowEditable*) base;
	_tmp0_ = self->priv->_key;
	result = G_TYPE_CHECK_INSTANCE_CAST (_tmp0_, TYPE_KEY, Key);
	return result;
}


static void key_list_box_row_editable_class_init (KeyListBoxRowEditableClass * klass) {
	key_list_box_row_editable_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (KeyListBoxRowEditablePrivate));
	((KeyListBoxRowClass *) klass)->update = key_list_box_row_editable_real_update;
	((ClickableListBoxRowClass *) klass)->get_text = key_list_box_row_editable_real_get_text;
	((ClickableListBoxRowClass *) klass)->generate_popover = key_list_box_row_editable_real_generate_popover;
	KEY_LIST_BOX_ROW_CLASS (klass)->get_abstract_key = key_list_box_row_editable_real_get_abstract_key;
	G_OBJECT_CLASS (klass)->get_property = _vala_key_list_box_row_editable_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_key_list_box_row_editable_set_property;
	G_OBJECT_CLASS (klass)->finalize = key_list_box_row_editable_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), KEY_LIST_BOX_ROW_EDITABLE_KEY, g_param_spec_object ("key", "key", "key", TYPE_GSETTINGS_KEY, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
}


static void key_list_box_row_editable_instance_init (KeyListBoxRowEditable * self) {
	self->priv = KEY_LIST_BOX_ROW_EDITABLE_GET_PRIVATE (self);
}


static void key_list_box_row_editable_finalize (GObject * obj) {
	KeyListBoxRowEditable * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_KEY_LIST_BOX_ROW_EDITABLE, KeyListBoxRowEditable);
	_g_object_unref0 (self->priv->_key);
	G_OBJECT_CLASS (key_list_box_row_editable_parent_class)->finalize (obj);
}


GType key_list_box_row_editable_get_type (void) {
	static volatile gsize key_list_box_row_editable_type_id__volatile = 0;
	if (g_once_init_enter (&key_list_box_row_editable_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (KeyListBoxRowEditableClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) key_list_box_row_editable_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (KeyListBoxRowEditable), 0, (GInstanceInitFunc) key_list_box_row_editable_instance_init, NULL };
		GType key_list_box_row_editable_type_id;
		key_list_box_row_editable_type_id = g_type_register_static (TYPE_KEY_LIST_BOX_ROW, "KeyListBoxRowEditable", &g_define_type_info, 0);
		g_once_init_leave (&key_list_box_row_editable_type_id__volatile, key_list_box_row_editable_type_id);
	}
	return key_list_box_row_editable_type_id__volatile;
}


static void _vala_key_list_box_row_editable_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	KeyListBoxRowEditable * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_KEY_LIST_BOX_ROW_EDITABLE, KeyListBoxRowEditable);
	switch (property_id) {
		case KEY_LIST_BOX_ROW_EDITABLE_KEY:
		g_value_set_object (value, key_list_box_row_editable_get_key (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_key_list_box_row_editable_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	KeyListBoxRowEditable * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_KEY_LIST_BOX_ROW_EDITABLE, KeyListBoxRowEditable);
	switch (property_id) {
		case KEY_LIST_BOX_ROW_EDITABLE_KEY:
		key_list_box_row_editable_set_key (self, g_value_get_object (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static gboolean _context_popover_on_key_press_event_gtk_widget_key_press_event (GtkWidget* _sender, GdkEventKey* event, gpointer self) {
	gboolean result;
	result = context_popover_on_key_press_event ((ContextPopover*) self, _sender, event);
	return result;
}


ContextPopover* context_popover_construct (GType object_type) {
	ContextPopover * self = NULL;
	GMenu* _tmp0_;
	self = (ContextPopover*) g_object_new (object_type, NULL);
	context_popover_new_section_real (self);
	_tmp0_ = self->priv->menu;
	gtk_popover_bind_model ((GtkPopover*) self, (GMenuModel*) _tmp0_, NULL);
	g_signal_connect_object ((GtkWidget*) self, "key-press-event", (GCallback) _context_popover_on_key_press_event_gtk_widget_key_press_event, self, 0);
	return self;
}


ContextPopover* context_popover_new (void) {
	return context_popover_construct (TYPE_CONTEXT_POPOVER);
}


static gboolean context_popover_on_key_press_event (ContextPopover* self, GtkWidget* widget, GdkEventKey* event) {
	gboolean result = FALSE;
	GdkEventKey* _tmp0_;
	guint _tmp1_;
	const gchar* _tmp2_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (widget != NULL, FALSE);
	g_return_val_if_fail (event != NULL, FALSE);
	_tmp0_ = event;
	_tmp1_ = _tmp0_->keyval;
	_tmp2_ = gdk_keyval_name (_tmp1_);
	if (g_strcmp0 (_tmp2_, "Menu") != 0) {
		result = FALSE;
		return result;
	}
	gtk_popover_popdown ((GtkPopover*) self);
	result = TRUE;
	return result;
}


static Block14Data* block14_data_ref (Block14Data* _data14_) {
	g_atomic_int_inc (&_data14_->_ref_count_);
	return _data14_;
}


static void block14_data_unref (void * _userdata_) {
	Block14Data* _data14_;
	_data14_ = (Block14Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data14_->_ref_count_)) {
		ContextPopover* self;
		self = _data14_->self;
		_g_object_unref0 (self);
		g_slice_free (Block14Data, _data14_);
	}
}


static const gchar* string_to_string (const gchar* self) {
	const gchar* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	result = self;
	return result;
}


static void __lambda26_ (Block14Data* _data14_) {
	ContextPopover* self;
	ContextPopoverbutton_action _tmp0_;
	void* _tmp0__target;
	self = _data14_->self;
	_tmp0_ = _data14_->action;
	_tmp0__target = _data14_->action_target;
	_tmp0_ (_tmp0__target);
}


static void ___lambda26__g_simple_action_activate (GSimpleAction* _sender, GVariant* parameter, gpointer self) {
	__lambda26_ (self);
}


void context_popover_new_action (ContextPopover* self, const gchar* action_action, ContextPopoverbutton_action action, void* action_target) {
	Block14Data* _data14_;
	ContextPopoverbutton_action _tmp0_;
	void* _tmp0__target;
	gchar* group_dot_action;
	const gchar* _tmp1_;
	const gchar* _tmp2_;
	gchar* _tmp3_;
	GSimpleAction* simple_action;
	const gchar* _tmp4_;
	GSimpleAction* _tmp5_;
	GSimpleAction* _tmp6_;
	GActionMap* _tmp7_;
	GSimpleAction* _tmp8_;
	const gchar* _tmp9_;
	const gchar* _tmp10_;
	GQuark _tmp12_ = 0U;
	static GQuark _tmp11_label0 = 0;
	static GQuark _tmp11_label1 = 0;
	static GQuark _tmp11_label2 = 0;
	static GQuark _tmp11_label3 = 0;
	static GQuark _tmp11_label4 = 0;
	static GQuark _tmp11_label5 = 0;
	static GQuark _tmp11_label6 = 0;
	g_return_if_fail (self != NULL);
	g_return_if_fail (action_action != NULL);
	_data14_ = g_slice_new0 (Block14Data);
	_data14_->_ref_count_ = 1;
	_data14_->self = g_object_ref (self);
	_tmp0_ = action;
	_tmp0__target = action_target;
	_data14_->action = _tmp0_;
	_data14_->action_target = _tmp0__target;
	context_popover_set_group (self, "options");
	_tmp1_ = action_action;
	_tmp2_ = string_to_string (_tmp1_);
	_tmp3_ = g_strconcat ("options.", _tmp2_, NULL);
	group_dot_action = _tmp3_;
	_tmp4_ = action_action;
	_tmp5_ = g_simple_action_new (_tmp4_, NULL);
	simple_action = _tmp5_;
	_tmp6_ = simple_action;
	g_signal_connect_data (_tmp6_, "activate", (GCallback) ___lambda26__g_simple_action_activate, block14_data_ref (_data14_), (GClosureNotify) block14_data_unref, 0);
	_tmp7_ = self->priv->current_group;
	_tmp8_ = simple_action;
	g_action_map_add_action (_tmp7_, (GAction*) _tmp8_);
	_tmp9_ = action_action;
	_tmp10_ = _tmp9_;
	_tmp12_ = (NULL == _tmp10_) ? 0 : g_quark_from_string (_tmp10_);
	if (_tmp12_ == ((0 != _tmp11_label0) ? _tmp11_label0 : (_tmp11_label0 = g_quark_from_static_string ("customize")))) {
		switch (0) {
			default:
			{
				GMenu* _tmp13_;
				const gchar* _tmp14_;
				_tmp13_ = self->priv->current_section;
				_tmp14_ = group_dot_action;
				g_menu_append (_tmp13_, _ ("Customize…"), _tmp14_);
				_g_object_unref0 (simple_action);
				g_free (group_dot_action);
				block14_data_unref (_data14_);
				_data14_ = NULL;
				return;
			}
		}
	} else if (_tmp12_ == ((0 != _tmp11_label1) ? _tmp11_label1 : (_tmp11_label1 = g_quark_from_static_string ("default1")))) {
		switch (0) {
			default:
			{
				GMenu* _tmp15_;
				const gchar* _tmp16_;
				_tmp15_ = self->priv->current_section;
				_tmp16_ = group_dot_action;
				g_menu_append (_tmp15_, _ ("Set to default"), _tmp16_);
				_g_object_unref0 (simple_action);
				g_free (group_dot_action);
				block14_data_unref (_data14_);
				_data14_ = NULL;
				return;
			}
		}
	} else if (_tmp12_ == ((0 != _tmp11_label2) ? _tmp11_label2 : (_tmp11_label2 = g_quark_from_static_string ("default2")))) {
		switch (0) {
			default:
			{
				const gchar* _tmp17_;
				_tmp17_ = group_dot_action;
				context_popover_new_multi_default_action (self, _tmp17_);
				_g_object_unref0 (simple_action);
				g_free (group_dot_action);
				block14_data_unref (_data14_);
				_data14_ = NULL;
				return;
			}
		}
	} else if (_tmp12_ == ((0 != _tmp11_label3) ? _tmp11_label3 : (_tmp11_label3 = g_quark_from_static_string ("dismiss")))) {
		switch (0) {
			default:
			{
				GMenu* _tmp18_;
				const gchar* _tmp19_;
				_tmp18_ = self->priv->current_section;
				_tmp19_ = group_dot_action;
				g_menu_append (_tmp18_, _ ("Dismiss change"), _tmp19_);
				_g_object_unref0 (simple_action);
				g_free (group_dot_action);
				block14_data_unref (_data14_);
				_data14_ = NULL;
				return;
			}
		}
	} else if (_tmp12_ == ((0 != _tmp11_label4) ? _tmp11_label4 : (_tmp11_label4 = g_quark_from_static_string ("open")))) {
		switch (0) {
			default:
			{
				GMenu* _tmp20_;
				const gchar* _tmp21_;
				_tmp20_ = self->priv->current_section;
				_tmp21_ = group_dot_action;
				g_menu_append (_tmp20_, _ ("Open"), _tmp21_);
				_g_object_unref0 (simple_action);
				g_free (group_dot_action);
				block14_data_unref (_data14_);
				_data14_ = NULL;
				return;
			}
		}
	} else if (_tmp12_ == ((0 != _tmp11_label5) ? _tmp11_label5 : (_tmp11_label5 = g_quark_from_static_string ("erase")))) {
		switch (0) {
			default:
			{
				GMenu* _tmp22_;
				const gchar* _tmp23_;
				_tmp22_ = self->priv->current_section;
				_tmp23_ = group_dot_action;
				g_menu_append (_tmp22_, _ ("Erase key"), _tmp23_);
				_g_object_unref0 (simple_action);
				g_free (group_dot_action);
				block14_data_unref (_data14_);
				_data14_ = NULL;
				return;
			}
		}
	} else if (_tmp12_ == ((0 != _tmp11_label6) ? _tmp11_label6 : (_tmp11_label6 = g_quark_from_static_string ("unerase")))) {
		switch (0) {
			default:
			{
				GMenu* _tmp24_;
				const gchar* _tmp25_;
				_tmp24_ = self->priv->current_section;
				_tmp25_ = group_dot_action;
				g_menu_append (_tmp24_, _ ("Do not erase"), _tmp25_);
				_g_object_unref0 (simple_action);
				g_free (group_dot_action);
				block14_data_unref (_data14_);
				_data14_ = NULL;
				return;
			}
		}
	} else {
		switch (0) {
			default:
			{
				g_assert_not_reached ();
			}
		}
	}
	_g_object_unref0 (simple_action);
	g_free (group_dot_action);
	block14_data_unref (_data14_);
	_data14_ = NULL;
}


void context_popover_new_copy_action (ContextPopover* self, const gchar* text) {
	GMenu* _tmp0_;
	const gchar* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	gchar* _tmp4_;
	gchar* _tmp5_;
	gchar* _tmp6_;
	gchar* _tmp7_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (text != NULL);
	_tmp0_ = self->priv->current_section;
	_tmp1_ = text;
	_tmp2_ = g_strescape (_tmp1_, "");
	_tmp3_ = _tmp2_;
	_tmp4_ = g_strconcat ("app.copy(\"", _tmp3_, NULL);
	_tmp5_ = _tmp4_;
	_tmp6_ = g_strconcat (_tmp5_, "\")", NULL);
	_tmp7_ = _tmp6_;
	g_menu_append (_tmp0_, _ ("Copy"), _tmp7_);
	g_free (_tmp7_);
	g_free (_tmp5_);
	g_free (_tmp3_);
}


void context_popover_set_group (ContextPopover* self, const gchar* group_name) {
	GActionGroup* group;
	const gchar* _tmp0_;
	GActionGroup* _tmp1_;
	GActionGroup* _tmp2_;
	GActionGroup* _tmp3_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (group_name != NULL);
	_tmp0_ = group_name;
	_tmp1_ = gtk_widget_get_action_group ((GtkWidget*) self, _tmp0_);
	_tmp2_ = _g_object_ref0 (_tmp1_);
	group = _tmp2_;
	_tmp3_ = group;
	if (_tmp3_ == NULL) {
		GSimpleActionGroup* _tmp4_;
		const gchar* _tmp5_;
		GActionMap* _tmp6_;
		_tmp4_ = g_simple_action_group_new ();
		_g_object_unref0 (self->priv->current_group);
		self->priv->current_group = (GActionMap*) _tmp4_;
		_tmp5_ = group_name;
		_tmp6_ = self->priv->current_group;
		gtk_widget_insert_action_group ((GtkWidget*) self, _tmp5_, (GActionGroup*) G_TYPE_CHECK_INSTANCE_CAST (_tmp6_, g_simple_action_group_get_type (), GSimpleActionGroup));
	} else {
		GActionGroup* _tmp7_;
		GActionMap* _tmp8_;
		_tmp7_ = group;
		_tmp8_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (G_TYPE_CHECK_INSTANCE_CAST (_tmp7_, g_action_group_get_type (), GActionGroup), g_action_map_get_type (), GActionMap));
		_g_object_unref0 (self->priv->current_group);
		self->priv->current_group = _tmp8_;
	}
	_g_object_unref0 (group);
}


void context_popover_new_section (ContextPopover* self) {
	GMenu* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->current_section;
	g_menu_freeze (_tmp0_);
	context_popover_new_section_real (self);
}


static void context_popover_new_section_real (ContextPopover* self) {
	GMenu* _tmp0_;
	GMenu* _tmp1_;
	GMenu* _tmp2_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_menu_new ();
	_g_object_unref0 (self->priv->current_section);
	self->priv->current_section = _tmp0_;
	_tmp1_ = self->priv->menu;
	_tmp2_ = self->priv->current_section;
	g_menu_append_section (_tmp1_, NULL, (GMenuModel*) _tmp2_);
}


static Block15Data* block15_data_ref (Block15Data* _data15_) {
	g_atomic_int_inc (&_data15_->_ref_count_);
	return _data15_;
}


static void block15_data_unref (void * _userdata_) {
	Block15Data* _data15_;
	_data15_ = (Block15Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data15_->_ref_count_)) {
		ContextPopover* self;
		self = _data15_->self;
		_data15_->flags_actions = (_vala_array_free (_data15_->flags_actions, _data15_->flags_actions_length1, (GDestroyNotify) g_object_unref), NULL);
		_data15_->active_flags = (_vala_array_free (_data15_->active_flags, _data15_->active_flags_length1, (GDestroyNotify) g_free), NULL);
		_g_object_unref0 (_data15_->key);
		_g_object_unref0 (self);
		g_slice_free (Block15Data, _data15_);
	}
}


static gchar** _vala_array_dup1 (gchar** self, int length) {
	gchar** result;
	int i;
	result = g_new0 (gchar*, length + 1);
	for (i = 0; i < length; i++) {
		gchar* _tmp0_;
		_tmp0_ = g_strdup (self[i]);
		result[i] = _tmp0_;
	}
	return result;
}


static Block16Data* block16_data_ref (Block16Data* _data16_) {
	g_atomic_int_inc (&_data16_->_ref_count_);
	return _data16_;
}


static void block16_data_unref (void * _userdata_) {
	Block16Data* _data16_;
	_data16_ = (Block16Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data16_->_ref_count_)) {
		ContextPopover* self;
		self = _data16_->_data15_->self;
		_g_object_unref0 (_data16_->simple_action);
		g_free (_data16_->flag);
		block15_data_unref (_data16_->_data15_);
		_data16_->_data15_ = NULL;
		g_slice_free (Block16Data, _data16_);
	}
}


static gboolean _vala_string_array_contains (gchar* * stack, int stack_length, gchar* needle) {
	int i;
	for (i = 0; i < stack_length; i++) {
		if (g_strcmp0 (stack[i], needle) == 0) {
			return TRUE;
		}
	}
	return FALSE;
}


static void _vala_array_add3 (GSimpleAction** * array, int* length, int* size, GSimpleAction* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (GSimpleAction*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


static void _vala_array_add4 (gchar** * array, int* length, int* size, gchar* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gchar*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


static void ____lambda27_ (Block16Data* _data16_, GSimpleAction* gaction, GVariant* gvariant) {
	Block15Data* _data15_;
	ContextPopover* self;
	GSimpleAction* _tmp0_;
	GVariant* _tmp1_;
	gchar** new_flags;
	gchar** _tmp2_;
	gint new_flags_length1;
	gint _new_flags_size_;
	GSimpleAction** _tmp3_;
	gint _tmp3__length1;
	GVariant* variant;
	gchar** _tmp16_;
	gint _tmp16__length1;
	GVariant* _tmp17_;
	_data15_ = _data16_->_data15_;
	self = _data15_->self;
	g_return_if_fail (gaction != NULL);
	_tmp0_ = gaction;
	_tmp1_ = gvariant;
	g_simple_action_set_state (_tmp0_, (GVariant*) _tmp1_);
	_tmp2_ = g_new0 (gchar*, 0 + 1);
	new_flags = _tmp2_;
	new_flags_length1 = 0;
	_new_flags_size_ = new_flags_length1;
	_tmp3_ = _data15_->flags_actions;
	_tmp3__length1 = _data15_->flags_actions_length1;
	{
		GSimpleAction** action_collection = NULL;
		gint action_collection_length1 = 0;
		gint _action_collection_size_ = 0;
		gint action_it = 0;
		action_collection = _tmp3_;
		action_collection_length1 = _tmp3__length1;
		for (action_it = 0; action_it < _tmp3__length1; action_it = action_it + 1) {
			GSimpleAction* _tmp4_;
			GSimpleAction* action = NULL;
			_tmp4_ = _g_object_ref0 (action_collection[action_it]);
			action = _tmp4_;
			{
				GSimpleAction* _tmp5_;
				GVariant* _tmp6_;
				GVariant* _tmp7_;
				GVariant* _tmp8_;
				gboolean _tmp9_;
				gboolean _tmp10_;
				_tmp5_ = action;
				_tmp6_ = g_action_get_state ((GAction*) _tmp5_);
				_tmp7_ = _tmp6_;
				_tmp8_ = (GVariant*) _tmp7_;
				_tmp9_ = g_variant_get_boolean (_tmp8_);
				_tmp10_ = _tmp9_;
				_g_variant_unref0 (_tmp8_);
				if (_tmp10_) {
					gchar** _tmp11_;
					gint _tmp11__length1;
					GSimpleAction* _tmp12_;
					const gchar* _tmp13_;
					const gchar* _tmp14_;
					gchar* _tmp15_;
					_tmp11_ = new_flags;
					_tmp11__length1 = new_flags_length1;
					_tmp12_ = action;
					_tmp13_ = g_action_get_name ((GAction*) _tmp12_);
					_tmp14_ = _tmp13_;
					_tmp15_ = g_strdup (_tmp14_);
					_vala_array_add4 (&new_flags, &new_flags_length1, &_new_flags_size_, _tmp15_);
				}
				_g_object_unref0 (action);
			}
		}
	}
	_tmp16_ = new_flags;
	_tmp16__length1 = new_flags_length1;
	_tmp17_ = g_variant_new_strv (_tmp16_, _tmp16__length1);
	g_variant_ref_sink (_tmp17_);
	variant = _tmp17_;
	g_signal_emit (self, context_popover_signals[CONTEXT_POPOVER_VALUE_CHANGED_SIGNAL], 0, variant);
	_g_variant_unref0 (variant);
	new_flags = (_vala_array_free (new_flags, new_flags_length1, (GDestroyNotify) g_free), NULL);
}


static void _____lambda27__g_simple_action_change_state (GSimpleAction* _sender, GVariant* value, gpointer self) {
	____lambda27_ (self, _sender, value);
}


static gchar** _vala_array_dup2 (gchar** self, int length) {
	gchar** result;
	int i;
	result = g_new0 (gchar*, length + 1);
	for (i = 0; i < length; i++) {
		gchar* _tmp0_;
		_tmp0_ = g_strdup (self[i]);
		result[i] = _tmp0_;
	}
	return result;
}


static void ____lambda28_ (Block16Data* _data16_) {
	Block15Data* _data15_;
	ContextPopover* self;
	const gchar** _tmp0_ = NULL;
	gint _tmp0__length1 = 0;
	gint __tmp0__size_ = 0;
	GSettingsKey* _tmp1_;
	GVariant* _tmp2_;
	GVariant* _tmp3_;
	gchar** _tmp15_;
	gint _tmp15__length1;
	gboolean active;
	const gchar* _tmp16_;
	gchar** _tmp17_;
	gint _tmp17__length1;
	gboolean _tmp18_;
	GSimpleAction* _tmp19_;
	GVariant* _tmp20_;
	GVariant* _tmp21_;
	gboolean _tmp22_;
	_data15_ = _data16_->_data15_;
	self = _data15_->self;
	_tmp1_ = _data15_->key;
	_tmp2_ = key_get_planned_value ((Key*) _tmp1_);
	_tmp3_ = _tmp2_;
	if (_tmp3_ != NULL) {
		GSettingsKey* _tmp4_;
		GVariant* _tmp5_;
		GVariant* _tmp6_;
		size_t _tmp7_;
		const gchar** _tmp8_;
		_tmp4_ = _data15_->key;
		_tmp5_ = key_get_planned_value ((Key*) _tmp4_);
		_tmp6_ = _tmp5_;
		_tmp8_ = g_variant_get_strv ((GVariant*) _tmp6_, &_tmp7_);
		_tmp0_ = (g_free (_tmp0_), NULL);
		_tmp0_ = _tmp8_;
		_tmp0__length1 = _tmp7_;
		__tmp0__size_ = _tmp0__length1;
	} else {
		GSettingsKey* _tmp9_;
		GVariant* _tmp10_;
		GVariant* _tmp11_;
		GVariant* _tmp12_;
		size_t _tmp13_;
		const gchar** _tmp14_;
		_tmp9_ = _data15_->key;
		_tmp10_ = key_get_value ((Key*) _tmp9_);
		_tmp11_ = _tmp10_;
		_tmp12_ = _tmp11_;
		_tmp14_ = g_variant_get_strv (_tmp12_, &_tmp13_);
		_tmp0_ = (g_free (_tmp0_), NULL);
		_tmp0_ = _tmp14_;
		_tmp0__length1 = _tmp13_;
		__tmp0__size_ = _tmp0__length1;
		_g_variant_unref0 (_tmp12_);
	}
	_tmp15_ = (_tmp0_ != NULL) ? _vala_array_dup2 (_tmp0_, _tmp0__length1) : ((gpointer) _tmp0_);
	_tmp15__length1 = _tmp0__length1;
	_data15_->active_flags = (_vala_array_free (_data15_->active_flags, _data15_->active_flags_length1, (GDestroyNotify) g_free), NULL);
	_data15_->active_flags = _tmp15_;
	_data15_->active_flags_length1 = _tmp15__length1;
	_data15_->_active_flags_size_ = _data15_->active_flags_length1;
	_tmp16_ = _data16_->flag;
	_tmp17_ = _data15_->active_flags;
	_tmp17__length1 = _data15_->active_flags_length1;
	active = _vala_string_array_contains (_tmp17_, _tmp17__length1, _tmp16_);
	_tmp18_ = active;
	_tmp19_ = _data16_->simple_action;
	_tmp20_ = g_action_get_state ((GAction*) _tmp19_);
	_tmp21_ = _tmp20_;
	_tmp22_ = _tmp18_ != _tmp21_;
	_g_variant_unref0 (_tmp21_);
	if (_tmp22_) {
		GSimpleAction* _tmp23_;
		gboolean _tmp24_;
		GVariant* _tmp25_;
		GVariant* _tmp26_;
		_tmp23_ = _data16_->simple_action;
		_tmp24_ = active;
		_tmp25_ = g_variant_new_boolean (_tmp24_);
		g_variant_ref_sink (_tmp25_);
		_tmp26_ = _tmp25_;
		g_simple_action_set_state (_tmp23_, _tmp26_);
		_g_variant_unref0 (_tmp26_);
	}
	_tmp0_ = (g_free (_tmp0_), NULL);
}


static void _____lambda28__g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self) {
	____lambda28_ (self);
}


void context_popover_create_flags_list (ContextPopover* self, GSettingsKey* key) {
	Block15Data* _data15_;
	GSettingsKey* _tmp0_;
	GSettingsKey* _tmp1_;
	gchar* group_dot;
	gchar* _tmp2_;
	GSettings* settings;
	GSettingsKey* _tmp3_;
	const gchar* _tmp4_;
	const gchar* _tmp5_;
	GSettings* _tmp6_;
	GSettings* _tmp7_;
	GSettingsKey* _tmp8_;
	const gchar* _tmp9_;
	const gchar* _tmp10_;
	gchar** _tmp11_;
	gchar** _tmp12_;
	gchar** all_flags;
	GSettingsKey* _tmp13_;
	GVariant* _tmp14_;
	GVariant* _tmp15_;
	size_t _tmp16_;
	const gchar** _tmp17_;
	gchar** _tmp18_;
	gint _tmp18__length1;
	gint all_flags_length1;
	gint _all_flags_size_;
	GSimpleAction** _tmp19_;
	gchar** _tmp20_;
	gint _tmp20__length1;
	g_return_if_fail (self != NULL);
	g_return_if_fail (key != NULL);
	_data15_ = g_slice_new0 (Block15Data);
	_data15_->_ref_count_ = 1;
	_data15_->self = g_object_ref (self);
	_tmp0_ = key;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (_data15_->key);
	_data15_->key = _tmp1_;
	context_popover_set_group (self, "flags");
	_tmp2_ = g_strdup ("flags.");
	group_dot = _tmp2_;
	_tmp3_ = _data15_->key;
	_tmp4_ = gsettings_key_get_schema_id (_tmp3_);
	_tmp5_ = _tmp4_;
	_tmp6_ = g_settings_new (_tmp5_);
	settings = _tmp6_;
	_tmp7_ = settings;
	_tmp8_ = _data15_->key;
	_tmp9_ = setting_object_get_name ((SettingObject*) _tmp8_);
	_tmp10_ = _tmp9_;
	_tmp12_ = _tmp11_ = g_settings_get_strv (_tmp7_, _tmp10_);
	_data15_->active_flags = _tmp12_;
	_data15_->active_flags_length1 = _vala_array_length (_tmp11_);
	_data15_->_active_flags_size_ = _data15_->active_flags_length1;
	_tmp13_ = _data15_->key;
	_tmp14_ = gsettings_key_get_range_content (_tmp13_);
	_tmp15_ = _tmp14_;
	_tmp17_ = g_variant_get_strv (_tmp15_, &_tmp16_);
	_tmp18_ = (_tmp17_ != NULL) ? _vala_array_dup1 (_tmp17_, _tmp16_) : ((gpointer) _tmp17_);
	_tmp18__length1 = _tmp16_;
	all_flags = _tmp18_;
	all_flags_length1 = _tmp18__length1;
	_all_flags_size_ = all_flags_length1;
	_tmp19_ = g_new0 (GSimpleAction*, 0 + 1);
	_data15_->flags_actions = _tmp19_;
	_data15_->flags_actions_length1 = 0;
	_data15_->_flags_actions_size_ = _data15_->flags_actions_length1;
	_tmp20_ = all_flags;
	_tmp20__length1 = all_flags_length1;
	{
		gchar** flag_collection = NULL;
		gint flag_collection_length1 = 0;
		gint _flag_collection_size_ = 0;
		gint flag_it = 0;
		flag_collection = _tmp20_;
		flag_collection_length1 = _tmp20__length1;
		for (flag_it = 0; flag_it < _tmp20__length1; flag_it = flag_it + 1) {
			gchar* _tmp21_;
			gchar* flag = NULL;
			_tmp21_ = g_strdup (flag_collection[flag_it]);
			flag = _tmp21_;
			{
				Block16Data* _data16_;
				const gchar* _tmp22_;
				const gchar* _tmp23_;
				gchar** _tmp24_;
				gint _tmp24__length1;
				GVariant* _tmp25_;
				GVariant* _tmp26_;
				GSimpleAction* _tmp27_;
				GSimpleAction* _tmp28_;
				GActionMap* _tmp29_;
				GSimpleAction* _tmp30_;
				GMenu* _tmp31_;
				const gchar* _tmp32_;
				const gchar* _tmp33_;
				const gchar* _tmp34_;
				gchar* _tmp35_;
				gchar* _tmp36_;
				GSimpleAction** _tmp37_;
				gint _tmp37__length1;
				GSimpleAction* _tmp38_;
				GSimpleAction* _tmp39_;
				GSimpleAction* _tmp40_;
				GSettingsKey* _tmp41_;
				_data16_ = g_slice_new0 (Block16Data);
				_data16_->_ref_count_ = 1;
				_data16_->_data15_ = block15_data_ref (_data15_);
				_data16_->flag = flag;
				_tmp22_ = _data16_->flag;
				_tmp23_ = _data16_->flag;
				_tmp24_ = _data15_->active_flags;
				_tmp24__length1 = _data15_->active_flags_length1;
				_tmp25_ = g_variant_new_boolean (_vala_string_array_contains (_tmp24_, _tmp24__length1, _tmp23_));
				g_variant_ref_sink (_tmp25_);
				_tmp26_ = _tmp25_;
				_tmp27_ = g_simple_action_new_stateful (_tmp22_, NULL, _tmp26_);
				_tmp28_ = _tmp27_;
				_g_variant_unref0 (_tmp26_);
				_data16_->simple_action = _tmp28_;
				_tmp29_ = self->priv->current_group;
				_tmp30_ = _data16_->simple_action;
				g_action_map_add_action (_tmp29_, (GAction*) _tmp30_);
				_tmp31_ = self->priv->current_section;
				_tmp32_ = _data16_->flag;
				_tmp33_ = group_dot;
				_tmp34_ = _data16_->flag;
				_tmp35_ = g_strconcat (_tmp33_, _tmp34_, NULL);
				_tmp36_ = _tmp35_;
				g_menu_append (_tmp31_, _tmp32_, _tmp36_);
				g_free (_tmp36_);
				_tmp37_ = _data15_->flags_actions;
				_tmp37__length1 = _data15_->flags_actions_length1;
				_tmp38_ = _data16_->simple_action;
				_tmp39_ = _g_object_ref0 (_tmp38_);
				_vala_array_add3 (&_data15_->flags_actions, &_data15_->flags_actions_length1, &_data15_->_flags_actions_size_, _tmp39_);
				_tmp40_ = _data16_->simple_action;
				g_signal_connect_data (_tmp40_, "change-state", (GCallback) _____lambda27__g_simple_action_change_state, block16_data_ref (_data16_), (GClosureNotify) block16_data_unref, 0);
				_tmp41_ = _data15_->key;
				g_signal_connect_data ((GObject*) _tmp41_, "notify::planned-value", (GCallback) _____lambda28__g_object_notify, block16_data_ref (_data16_), (GClosureNotify) block16_data_unref, 0);
				block16_data_unref (_data16_);
				_data16_ = NULL;
			}
		}
	}
	context_popover_finalize_menu (self);
	all_flags = (_vala_array_free (all_flags, all_flags_length1, (GDestroyNotify) g_free), NULL);
	_g_object_unref0 (settings);
	g_free (group_dot);
	block15_data_unref (_data15_);
	_data15_ = NULL;
}


static gpointer _g_variant_type_copy0 (gpointer self) {
	return self ? g_variant_type_copy (self) : NULL;
}


static gpointer _g_variant_ref0 (gpointer self) {
	return self ? g_variant_ref (self) : NULL;
}


static void __lambda29_ (ContextPopover* self, const gchar* unknown_string, GVariant* tmp_variant) {
	GVariant* change_variant;
	GVariant* _tmp0_;
	GVariant* _tmp1_;
	GVariant* _tmp2_;
	g_return_if_fail (unknown_string != NULL);
	g_return_if_fail (tmp_variant != NULL);
	_tmp0_ = tmp_variant;
	_tmp1_ = g_variant_get_maybe (_tmp0_);
	change_variant = _tmp1_;
	_tmp2_ = change_variant;
	if (_tmp2_ != NULL) {
		GVariant* _tmp3_;
		GVariant* _tmp4_;
		GVariant* _tmp5_;
		_tmp3_ = change_variant;
		_tmp4_ = g_variant_get_maybe ((GVariant*) _tmp3_);
		_tmp5_ = _tmp4_;
		g_signal_emit (self, context_popover_signals[CONTEXT_POPOVER_VALUE_CHANGED_SIGNAL], 0, _tmp5_);
		_g_variant_unref0 (_tmp5_);
	} else {
		g_signal_emit (self, context_popover_signals[CONTEXT_POPOVER_CHANGE_DISMISSED_SIGNAL], 0);
	}
	_g_variant_unref0 (change_variant);
}


static void ___lambda29__g_action_group_action_state_changed (GActionGroup* _sender, const gchar* action_name, GVariant* state, gpointer self) {
	__lambda29_ ((ContextPopover*) self, action_name, state);
}


GAction* context_popover_create_buttons_list (ContextPopover* self, Key* key, gboolean has_default_value, gboolean delayed_apply_menu) {
	GAction* result = NULL;
	static const char ACTION_NAME[] = "choice";
	gchar* group_dot_action;
	gchar* _tmp0_;
	GVariantType* original_type;
	Key* _tmp1_;
	GVariant* _tmp2_;
	GVariant* _tmp3_;
	GVariant* _tmp4_;
	const GVariantType* _tmp5_;
	GVariantType* _tmp6_;
	GVariantType* _tmp7_;
	GVariantType* nullable_type;
	const GVariantType* _tmp8_;
	GVariantType* _tmp9_;
	GVariantType* nullable_nullable_type;
	const GVariantType* _tmp10_;
	GVariantType* _tmp11_;
	gchar* type_string;
	const GVariantType* _tmp12_;
	gchar* _tmp13_;
	GVariant* value_variant = NULL;
	gboolean _tmp14_;
	GVariant* variant;
	const GVariantType* _tmp46_;
	GVariant* _tmp47_;
	GVariant* _tmp48_;
	GVariant* nullable_variant = NULL;
	gboolean _tmp49_ = FALSE;
	gboolean _tmp50_;
	GAction* action;
	const GVariantType* _tmp59_;
	GVariant* _tmp60_;
	GSimpleAction* _tmp61_;
	GActionMap* _tmp62_;
	GAction* _tmp63_;
	gboolean _tmp64_;
	Key* _tmp93_;
	const gchar* _tmp94_;
	const gchar* _tmp95_;
	const gchar* _tmp96_;
	GQuark _tmp98_ = 0U;
	static GQuark _tmp97_label0 = 0;
	static GQuark _tmp97_label1 = 0;
	static GQuark _tmp97_label2 = 0;
	GActionMap* _tmp173_;
	gchar* _tmp174_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (key != NULL, NULL);
	context_popover_set_group (self, "enum");
	_tmp0_ = g_strdup ("enum.choice");
	group_dot_action = _tmp0_;
	_tmp1_ = key;
	_tmp2_ = key_get_value (_tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = _tmp3_;
	_tmp5_ = g_variant_get_type (_tmp4_);
	_tmp6_ = _g_variant_type_copy0 (_tmp5_);
	_tmp7_ = _tmp6_;
	_g_variant_unref0 (_tmp4_);
	original_type = _tmp7_;
	_tmp8_ = original_type;
	_tmp9_ = g_variant_type_new_maybe (_tmp8_);
	nullable_type = _tmp9_;
	_tmp10_ = nullable_type;
	_tmp11_ = g_variant_type_new_maybe (_tmp10_);
	nullable_nullable_type = _tmp11_;
	_tmp12_ = original_type;
	_tmp13_ = g_variant_type_dup_string (_tmp12_);
	type_string = _tmp13_;
	_tmp14_ = has_default_value;
	if (!_tmp14_) {
		GVariant* _tmp15_ = NULL;
		gboolean _tmp16_ = FALSE;
		Key* _tmp17_;
		gboolean _tmp18_;
		gboolean _tmp19_;
		GVariant* _tmp30_;
		_tmp17_ = key;
		_tmp18_ = key_get_planned_change (_tmp17_);
		_tmp19_ = _tmp18_;
		if (_tmp19_) {
			Key* _tmp20_;
			GVariant* _tmp21_;
			GVariant* _tmp22_;
			_tmp20_ = key;
			_tmp21_ = key_get_planned_value (_tmp20_);
			_tmp22_ = _tmp21_;
			_tmp16_ = _tmp22_ != NULL;
		} else {
			_tmp16_ = FALSE;
		}
		if (_tmp16_) {
			Key* _tmp23_;
			GVariant* _tmp24_;
			GVariant* _tmp25_;
			GVariant* _tmp26_;
			_tmp23_ = key;
			_tmp24_ = key_get_planned_value (_tmp23_);
			_tmp25_ = _tmp24_;
			_tmp26_ = _g_variant_ref0 (_tmp25_);
			_g_variant_unref0 (_tmp15_);
			_tmp15_ = _tmp26_;
		} else {
			Key* _tmp27_;
			GVariant* _tmp28_;
			GVariant* _tmp29_;
			_tmp27_ = key;
			_tmp28_ = key_get_value (_tmp27_);
			_tmp29_ = _tmp28_;
			_g_variant_unref0 (_tmp15_);
			_tmp15_ = _tmp29_;
		}
		_tmp30_ = _g_variant_ref0 (_tmp15_);
		_g_variant_unref0 (value_variant);
		value_variant = _tmp30_;
		_g_variant_unref0 (_tmp15_);
	} else {
		Key* _tmp31_;
		gboolean _tmp32_;
		gboolean _tmp33_;
		_tmp31_ = key;
		_tmp32_ = key_get_planned_change (_tmp31_);
		_tmp33_ = _tmp32_;
		if (_tmp33_) {
			Key* _tmp34_;
			GVariant* _tmp35_;
			GVariant* _tmp36_;
			GVariant* _tmp37_;
			_tmp34_ = key;
			_tmp35_ = key_get_planned_value (_tmp34_);
			_tmp36_ = _tmp35_;
			_tmp37_ = _g_variant_ref0 (_tmp36_);
			_g_variant_unref0 (value_variant);
			value_variant = _tmp37_;
		} else {
			gboolean _tmp38_ = FALSE;
			Key* _tmp39_;
			_tmp39_ = key;
			if (G_TYPE_CHECK_INSTANCE_TYPE (_tmp39_, TYPE_GSETTINGS_KEY)) {
				Key* _tmp40_;
				gboolean _tmp41_;
				gboolean _tmp42_;
				_tmp40_ = key;
				_tmp41_ = gsettings_key_get_is_default (G_TYPE_CHECK_INSTANCE_CAST (_tmp40_, TYPE_GSETTINGS_KEY, GSettingsKey));
				_tmp42_ = _tmp41_;
				_tmp38_ = _tmp42_;
			} else {
				_tmp38_ = FALSE;
			}
			if (_tmp38_) {
				_g_variant_unref0 (value_variant);
				value_variant = NULL;
			} else {
				Key* _tmp43_;
				GVariant* _tmp44_;
				GVariant* _tmp45_;
				_tmp43_ = key;
				_tmp44_ = key_get_value (_tmp43_);
				_tmp45_ = _tmp44_;
				_g_variant_unref0 (value_variant);
				value_variant = _tmp45_;
			}
		}
	}
	_tmp46_ = original_type;
	_tmp47_ = value_variant;
	_tmp48_ = g_variant_new_maybe (_tmp46_, _tmp47_);
	g_variant_ref_sink (_tmp48_);
	variant = _tmp48_;
	_tmp50_ = delayed_apply_menu;
	if (_tmp50_) {
		Key* _tmp51_;
		gboolean _tmp52_;
		gboolean _tmp53_;
		_tmp51_ = key;
		_tmp52_ = key_get_planned_change (_tmp51_);
		_tmp53_ = _tmp52_;
		_tmp49_ = !_tmp53_;
	} else {
		_tmp49_ = FALSE;
	}
	if (_tmp49_) {
		const GVariantType* _tmp54_;
		GVariant* _tmp55_;
		_tmp54_ = nullable_type;
		_tmp55_ = g_variant_new_maybe (_tmp54_, NULL);
		g_variant_ref_sink (_tmp55_);
		_g_variant_unref0 (nullable_variant);
		nullable_variant = _tmp55_;
	} else {
		const GVariantType* _tmp56_;
		GVariant* _tmp57_;
		GVariant* _tmp58_;
		_tmp56_ = nullable_type;
		_tmp57_ = variant;
		_tmp58_ = g_variant_new_maybe (_tmp56_, _tmp57_);
		g_variant_ref_sink (_tmp58_);
		_g_variant_unref0 (nullable_variant);
		nullable_variant = _tmp58_;
	}
	_tmp59_ = nullable_nullable_type;
	_tmp60_ = nullable_variant;
	_tmp61_ = g_simple_action_new_stateful (ACTION_NAME, _tmp59_, _tmp60_);
	action = G_TYPE_CHECK_INSTANCE_CAST (_tmp61_, g_action_get_type (), GAction);
	_tmp62_ = self->priv->current_group;
	_tmp63_ = action;
	g_action_map_add_action (_tmp62_, _tmp63_);
	_tmp64_ = has_default_value;
	if (_tmp64_) {
		gboolean _tmp65_ = FALSE;
		gboolean _tmp66_;
		gboolean complete_menu;
		gboolean _tmp70_;
		Key* _tmp78_;
		_tmp66_ = delayed_apply_menu;
		if (_tmp66_) {
			_tmp65_ = TRUE;
		} else {
			Key* _tmp67_;
			gboolean _tmp68_;
			gboolean _tmp69_;
			_tmp67_ = key;
			_tmp68_ = key_get_planned_change (_tmp67_);
			_tmp69_ = _tmp68_;
			_tmp65_ = _tmp69_;
		}
		complete_menu = _tmp65_;
		_tmp70_ = complete_menu;
		if (_tmp70_) {
			GMenu* _tmp71_;
			const gchar* _tmp72_;
			const gchar* _tmp73_;
			const gchar* _tmp74_;
			const gchar* _tmp75_;
			gchar* _tmp76_;
			gchar* _tmp77_;
			_tmp71_ = self->priv->current_section;
			_tmp72_ = group_dot_action;
			_tmp73_ = string_to_string (_tmp72_);
			_tmp74_ = type_string;
			_tmp75_ = string_to_string (_tmp74_);
			_tmp76_ = g_strconcat (_tmp73_, "(@mm", _tmp75_, " nothing)", NULL);
			_tmp77_ = _tmp76_;
			g_menu_append (_tmp71_, _ ("No change"), _tmp77_);
			g_free (_tmp77_);
		}
		_tmp78_ = key;
		if (G_TYPE_CHECK_INSTANCE_TYPE (_tmp78_, TYPE_GSETTINGS_KEY)) {
			const gchar* _tmp79_;
			const gchar* _tmp80_;
			const gchar* _tmp81_;
			const gchar* _tmp82_;
			gchar* _tmp83_;
			gchar* _tmp84_;
			_tmp79_ = group_dot_action;
			_tmp80_ = string_to_string (_tmp79_);
			_tmp81_ = type_string;
			_tmp82_ = string_to_string (_tmp81_);
			_tmp83_ = g_strconcat (_tmp80_, "(@mm", _tmp82_, " just nothing)", NULL);
			_tmp84_ = _tmp83_;
			context_popover_new_multi_default_action (self, _tmp84_);
			g_free (_tmp84_);
		} else {
			gboolean _tmp85_;
			_tmp85_ = complete_menu;
			if (_tmp85_) {
				GMenu* _tmp86_;
				const gchar* _tmp87_;
				const gchar* _tmp88_;
				const gchar* _tmp89_;
				const gchar* _tmp90_;
				gchar* _tmp91_;
				gchar* _tmp92_;
				_tmp86_ = self->priv->current_section;
				_tmp87_ = group_dot_action;
				_tmp88_ = string_to_string (_tmp87_);
				_tmp89_ = type_string;
				_tmp90_ = string_to_string (_tmp89_);
				_tmp91_ = g_strconcat (_tmp88_, "(@mm", _tmp90_, " just nothing)", NULL);
				_tmp92_ = _tmp91_;
				g_menu_append (_tmp86_, _ ("Erase key"), _tmp92_);
				g_free (_tmp92_);
			}
		}
	}
	_tmp93_ = key;
	_tmp94_ = key_get_type_string (_tmp93_);
	_tmp95_ = _tmp94_;
	_tmp96_ = _tmp95_;
	_tmp98_ = (NULL == _tmp96_) ? 0 : g_quark_from_string (_tmp96_);
	if (_tmp98_ == ((0 != _tmp97_label0) ? _tmp97_label0 : (_tmp97_label0 = g_quark_from_static_string ("b")))) {
		switch (0) {
			default:
			{
				GMenu* _tmp99_;
				gboolean _tmp100_;
				gchar* _tmp101_;
				gchar* _tmp102_;
				const gchar* _tmp103_;
				const gchar* _tmp104_;
				gchar* _tmp105_;
				gchar* _tmp106_;
				GMenu* _tmp107_;
				gboolean _tmp108_;
				gchar* _tmp109_;
				gchar* _tmp110_;
				const gchar* _tmp111_;
				const gchar* _tmp112_;
				gchar* _tmp113_;
				gchar* _tmp114_;
				_tmp99_ = self->priv->current_section;
				_tmp100_ = TRUE;
				_tmp101_ = key_cool_boolean_text_value (&_tmp100_, TRUE);
				_tmp102_ = _tmp101_;
				_tmp103_ = group_dot_action;
				_tmp104_ = string_to_string (_tmp103_);
				_tmp105_ = g_strconcat (_tmp104_, "(@mmb true)", NULL);
				_tmp106_ = _tmp105_;
				g_menu_append (_tmp99_, _tmp102_, _tmp106_);
				g_free (_tmp106_);
				g_free (_tmp102_);
				_tmp107_ = self->priv->current_section;
				_tmp108_ = FALSE;
				_tmp109_ = key_cool_boolean_text_value (&_tmp108_, TRUE);
				_tmp110_ = _tmp109_;
				_tmp111_ = group_dot_action;
				_tmp112_ = string_to_string (_tmp111_);
				_tmp113_ = g_strconcat (_tmp112_, "(@mmb false)", NULL);
				_tmp114_ = _tmp113_;
				g_menu_append (_tmp107_, _tmp110_, _tmp114_);
				g_free (_tmp114_);
				g_free (_tmp110_);
				break;
			}
		}
	} else if (_tmp98_ == ((0 != _tmp97_label1) ? _tmp97_label1 : (_tmp97_label1 = g_quark_from_static_string ("<enum>")))) {
		switch (0) {
			default:
			{
				GVariant* range;
				Key* _tmp115_;
				GVariant* _tmp116_;
				GVariant* _tmp117_;
				GVariant* _tmp118_;
				guint size;
				GVariant* _tmp119_;
				gsize _tmp120_;
				gboolean _tmp121_ = FALSE;
				guint _tmp122_;
				_tmp115_ = key;
				_tmp116_ = gsettings_key_get_range_content (G_TYPE_CHECK_INSTANCE_CAST (_tmp115_, TYPE_GSETTINGS_KEY, GSettingsKey));
				_tmp117_ = _tmp116_;
				_tmp118_ = _g_variant_ref0 (_tmp117_);
				range = _tmp118_;
				_tmp119_ = range;
				_tmp120_ = g_variant_n_children (_tmp119_);
				size = (guint) _tmp120_;
				_tmp122_ = size;
				if (_tmp122_ == ((guint) 0)) {
					_tmp121_ = TRUE;
				} else {
					gboolean _tmp123_ = FALSE;
					guint _tmp124_;
					_tmp124_ = size;
					if (_tmp124_ == ((guint) 1)) {
						gboolean _tmp125_;
						_tmp125_ = has_default_value;
						_tmp123_ = !_tmp125_;
					} else {
						_tmp123_ = FALSE;
					}
					_tmp121_ = _tmp123_;
				}
				if (_tmp121_) {
					g_assert_not_reached ();
				}
				{
					guint index;
					index = (guint) 0;
					{
						gboolean _tmp126_;
						_tmp126_ = TRUE;
						while (TRUE) {
							guint _tmp128_;
							guint _tmp129_;
							GMenu* _tmp130_;
							GVariant* _tmp131_;
							guint _tmp132_;
							GVariant* _tmp133_;
							GVariant* _tmp134_;
							gchar* _tmp135_;
							gchar* _tmp136_;
							const gchar* _tmp137_;
							const gchar* _tmp138_;
							gchar* _tmp139_;
							gchar* _tmp140_;
							GVariant* _tmp141_;
							guint _tmp142_;
							GVariant* _tmp143_;
							GVariant* _tmp144_;
							const gchar* _tmp145_;
							gchar* _tmp146_;
							gchar* _tmp147_;
							gchar* _tmp148_;
							gchar* _tmp149_;
							if (!_tmp126_) {
								guint _tmp127_;
								_tmp127_ = index;
								index = _tmp127_ + 1;
							}
							_tmp126_ = FALSE;
							_tmp128_ = index;
							_tmp129_ = size;
							if (!(_tmp128_ < _tmp129_)) {
								break;
							}
							_tmp130_ = self->priv->current_section;
							_tmp131_ = range;
							_tmp132_ = index;
							_tmp133_ = g_variant_get_child_value (_tmp131_, (gsize) _tmp132_);
							_tmp134_ = _tmp133_;
							_tmp135_ = g_variant_print (_tmp134_, FALSE);
							_tmp136_ = _tmp135_;
							_tmp137_ = group_dot_action;
							_tmp138_ = string_to_string (_tmp137_);
							_tmp139_ = g_strconcat (_tmp138_, "(@mms '", NULL);
							_tmp140_ = _tmp139_;
							_tmp141_ = range;
							_tmp142_ = index;
							_tmp143_ = g_variant_get_child_value (_tmp141_, (gsize) _tmp142_);
							_tmp144_ = _tmp143_;
							_tmp145_ = g_variant_get_string (_tmp144_, NULL);
							_tmp146_ = g_strconcat (_tmp140_, _tmp145_, NULL);
							_tmp147_ = _tmp146_;
							_tmp148_ = g_strconcat (_tmp147_, "')", NULL);
							_tmp149_ = _tmp148_;
							g_menu_append (_tmp130_, _tmp136_, _tmp149_);
							g_free (_tmp149_);
							g_free (_tmp147_);
							_g_variant_unref0 (_tmp144_);
							g_free (_tmp140_);
							g_free (_tmp136_);
							_g_variant_unref0 (_tmp134_);
						}
					}
				}
				_g_variant_unref0 (range);
				break;
			}
		}
	} else if (_tmp98_ == ((0 != _tmp97_label2) ? _tmp97_label2 : (_tmp97_label2 = g_quark_from_static_string ("mb")))) {
		switch (0) {
			default:
			{
				GMenu* _tmp150_;
				gchar* _tmp151_;
				gchar* _tmp152_;
				const gchar* _tmp153_;
				const gchar* _tmp154_;
				gchar* _tmp155_;
				gchar* _tmp156_;
				GMenu* _tmp157_;
				gboolean _tmp158_;
				gchar* _tmp159_;
				gchar* _tmp160_;
				const gchar* _tmp161_;
				const gchar* _tmp162_;
				gchar* _tmp163_;
				gchar* _tmp164_;
				GMenu* _tmp165_;
				gboolean _tmp166_;
				gchar* _tmp167_;
				gchar* _tmp168_;
				const gchar* _tmp169_;
				const gchar* _tmp170_;
				gchar* _tmp171_;
				gchar* _tmp172_;
				_tmp150_ = self->priv->current_section;
				_tmp151_ = key_cool_boolean_text_value (NULL, TRUE);
				_tmp152_ = _tmp151_;
				_tmp153_ = group_dot_action;
				_tmp154_ = string_to_string (_tmp153_);
				_tmp155_ = g_strconcat (_tmp154_, "(@mmmb just just nothing)", NULL);
				_tmp156_ = _tmp155_;
				g_menu_append (_tmp150_, _tmp152_, _tmp156_);
				g_free (_tmp156_);
				g_free (_tmp152_);
				_tmp157_ = self->priv->current_section;
				_tmp158_ = TRUE;
				_tmp159_ = key_cool_boolean_text_value (&_tmp158_, TRUE);
				_tmp160_ = _tmp159_;
				_tmp161_ = group_dot_action;
				_tmp162_ = string_to_string (_tmp161_);
				_tmp163_ = g_strconcat (_tmp162_, "(@mmmb true)", NULL);
				_tmp164_ = _tmp163_;
				g_menu_append (_tmp157_, _tmp160_, _tmp164_);
				g_free (_tmp164_);
				g_free (_tmp160_);
				_tmp165_ = self->priv->current_section;
				_tmp166_ = FALSE;
				_tmp167_ = key_cool_boolean_text_value (&_tmp166_, TRUE);
				_tmp168_ = _tmp167_;
				_tmp169_ = group_dot_action;
				_tmp170_ = string_to_string (_tmp169_);
				_tmp171_ = g_strconcat (_tmp170_, "(@mmmb false)", NULL);
				_tmp172_ = _tmp171_;
				g_menu_append (_tmp165_, _tmp168_, _tmp172_);
				g_free (_tmp172_);
				g_free (_tmp168_);
				break;
			}
		}
	}
	_tmp173_ = self->priv->current_group;
	_tmp174_ = g_strconcat ("action-state-changed::", ACTION_NAME, NULL);
	g_signal_connect_object (G_TYPE_CHECK_INSTANCE_CAST (_tmp173_, g_action_group_get_type (), GActionGroup), _tmp174_, (GCallback) ___lambda29__g_action_group_action_state_changed, self, 0);
	g_free (_tmp174_);
	context_popover_finalize_menu (self);
	result = action;
	_g_variant_unref0 (nullable_variant);
	_g_variant_unref0 (variant);
	_g_variant_unref0 (value_variant);
	g_free (type_string);
	_g_variant_type_free0 (nullable_nullable_type);
	_g_variant_type_free0 (nullable_type);
	_g_variant_type_free0 (original_type);
	g_free (group_dot_action);
	return result;
}


static void context_popover_new_multi_default_action (ContextPopover* self, const gchar* action) {
	GMenu* _tmp0_;
	const gchar* _tmp1_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (action != NULL);
	_tmp0_ = self->priv->current_section;
	_tmp1_ = action;
	g_menu_append (_tmp0_, _ ("Default value"), _tmp1_);
}


static void context_popover_finalize_menu (ContextPopover* self) {
	GMenu* _tmp0_;
	gboolean _tmp1_;
	GMenu* _tmp2_;
	GMenu* _tmp3_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->menu;
	_tmp1_ = g_menu_model_is_mutable ((GMenuModel*) _tmp0_);
	_vala_return_if_fail (_tmp1_, "menu.is_mutable ()");
	_tmp2_ = self->priv->current_section;
	g_menu_freeze (_tmp2_);
	_tmp3_ = self->priv->menu;
	g_menu_freeze (_tmp3_);
}


static void context_popover_class_init (ContextPopoverClass * klass) {
	context_popover_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (ContextPopoverPrivate));
	G_OBJECT_CLASS (klass)->finalize = context_popover_finalize;
	context_popover_signals[CONTEXT_POPOVER_VALUE_CHANGED_SIGNAL] = g_signal_new ("value_changed", TYPE_CONTEXT_POPOVER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__VARIANT, G_TYPE_NONE, 1, G_TYPE_VARIANT);
	context_popover_signals[CONTEXT_POPOVER_CHANGE_DISMISSED_SIGNAL] = g_signal_new ("change_dismissed", TYPE_CONTEXT_POPOVER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
}


static void context_popover_instance_init (ContextPopover * self) {
	GMenu* _tmp0_;
	self->priv = CONTEXT_POPOVER_GET_PRIVATE (self);
	_tmp0_ = g_menu_new ();
	self->priv->menu = _tmp0_;
}


static void context_popover_finalize (GObject * obj) {
	ContextPopover * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_CONTEXT_POPOVER, ContextPopover);
	_g_object_unref0 (self->priv->menu);
	_g_object_unref0 (self->priv->current_section);
	_g_object_unref0 (self->priv->current_group);
	G_OBJECT_CLASS (context_popover_parent_class)->finalize (obj);
}


GType context_popover_get_type (void) {
	static volatile gsize context_popover_type_id__volatile = 0;
	if (g_once_init_enter (&context_popover_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ContextPopoverClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) context_popover_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ContextPopover), 0, (GInstanceInitFunc) context_popover_instance_init, NULL };
		GType context_popover_type_id;
		context_popover_type_id = g_type_register_static (gtk_popover_get_type (), "ContextPopover", &g_define_type_info, 0);
		g_once_init_leave (&context_popover_type_id__volatile, context_popover_type_id);
	}
	return context_popover_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



